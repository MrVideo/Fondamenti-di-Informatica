<!DOCTYPE html>
<html>
    <head>
        <title>Introduzione al C</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="bear-note-unique-identifier" content="C9E9A9D2-2550-4771-82BF-14904558B2FC-701-0000005CCB078F5C">
        <meta name="created" content="2020-09-28T08:25:09+0200"/>
        <meta name="modified" content="2020-11-23T10:07:40+0100"/>
        <meta name="tags" content="università, università/informatica"/>
        <meta name="last device" content="MacBook Pro di Mario"/>
    </head>
    <body>
        <div class="note-wrapper">
            <h1 id="Introduzione al C">Introduzione al C</h1>
<p><span class='hashtag'>#università/informatica</span></p>
<hr>
<h1 id="Indice">Indice</h1>
<ul><li><a href="#Primo programma in C"">/Primo programma in C</a>
</li><li><a href="#Variabili"">/Variabili</a>
</li><li><a href="#Input da tastiera"">/Input da tastiera</a>
</li><li><a href="#Tipi di dati"">/Tipi di dati</a>
<ul><li>	<a href="#Tipo int"">/Tipo int</a>
</li><li>	<a href="#Tipo float"">/Tipo float</a>
</li><li>	<a href="#Tipo char"">/Tipo char</a>
</li><li>	<a href="#Tipo enum"">/Tipo enum</a>
</li><li>	<a href="#Ridefinizione di tipo"">/Ridefinizione di tipo</a>
</li><li>	<a href="#Costanti"">/Costanti</a>
</li><li>	<a href="#Conversioni di tipo"">/Conversioni di tipo</a>
</li><li>	<a href="#Funzione sizeof"">/Funzione sizeof</a>
</li></ul></li><li><a href="#Istruzioni condizionali"">/Istruzioni condizionali</a>
<ul><li>	<a href="#If statement"">/If statement</a>
</li><li>	<a href="#Vero e falso in C"">/Vero e falso in C</a>
</li><li>	<a href="#Operatori relazionali"">/Operatori relazionali</a>
</li><li>	<a href="#Operatori logici"">/Operatori logici</a>
</li><li>	<a href="#Ordine tra gli operatori"">/Ordine tra gli operatori</a>
</li><li>	<a href="#If - else statement"">/If - else statement</a>
</li><li>	<a href="#Statement composti"">/Statement composti</a>
</li><li>	<a href="#Switch statement"">/Switch statement</a>
</li><li>	<a href="#Cicli"">/Cicli</a>
</li><li>	<a href="#Ciclo for"">/Ciclo for</a> 
</li><li>	<a href="#Ciclo while"">/Ciclo while</a>
</li><li>	<a href="#Ciclo do-while"">/Ciclo do-while</a>
</li><li>	<a href="#Istruzioni break e continue"">/Istruzioni break e continue</a>
</li></ul></li><li><a href="#Funzioni in C"">/Funzioni in C</a>
<ul><li>	<a href="#Funzioni senza parametri o ritorno"">/Funzioni senza parametri o ritorno</a>
</li><li>	<a href="#Funzioni con parametri"">/Funzioni con parametri</a>
</li><li>	<a href="#Funzioni con valori di ritorno"">/Funzioni con valori di ritorno</a>
</li><li>	<a href="#Dichiarazione di una funzione"">/Dichiarazione di una funzione</a>
</li><li>	<a href="#Definizione di una funzione"">/Definizione di una funzione</a>
</li><li>	<a href="#Visibilità delle variabili - Scoping"">/Visibilità delle variabili - Scoping</a>
</li><li>	<a href="#Vita di una variabile"">/Vita di una variabile</a>
</li><li>	<a href="#Regole di Scoping e funzioni"">/Regole di Scoping e funzioni</a>
</li></ul></li><li><a href="#Dati strutturati in C"">/Dati strutturati in C</a>
<ul><li>	<a href="#Array"">/Array</a>
<ul><li>		<a href="#Lettura e scrittura di un Array"">/Lettura e scrittura di un Array</a>
</li><li>		<a href="#Range"">/Range</a>
</li><li>		<a href="#Subscript"">/Subscript</a>
</li><li>		<a href="#Copia e confronto di array"">/Copia e confronto di array</a>
</li><li>		<a href="#Array e funzioni"">/Array e funzioni</a>
</li></ul></li><li>	<a href="#Stringhe"">/Stringhe</a> 
<ul><li>		<a href="#Carattere terminatore"">/Carattere terminatore</a>
</li><li>		<a href="#Copia e confronto di stringhe"">/Copia e confronto di stringhe</a>
</li><li>		<a href="#Stringhe e funzioni"">/Stringhe e funzioni</a>
</li><li>		<a href="#Matrici"">/Matrici</a>
</li><li>		<a href="#Struct"">/Struct</a>
</li><li>		<a href="#Struct con nome e typedef"">/Struct con nome e typedef</a>
</li><li>		<a href="#Array di struct"">/Array di struct</a>
</li><li>		<a href="#Assegnamento, confronto e funzioni con struct"">/Assegnamento, confronto e funzioni con struct</a>
</li><li>		<a href="#Struct come campi"">/Struct come campi</a>
</li></ul></li><li>	<a href="#Programmazione ricorsiva"">/Programmazione ricorsiva</a>
<ul><li>		<a href="#Problemi nell’uso della ricorsione"">/Problemi nell’uso della ricorsione</a>
</li></ul></li></ul></li><li><a href="#Puntatori"">/Puntatori</a>
<ul><li>	<a href="#Un modello “concettuale” della memoria"">/Un modello “concettuale” della memoria</a>
</li><li>	 <a href="#Variabili e memoria"">/Variabili e memoria</a>
</li><li>	<a href="#Cos’è un puntatore?"">/Cos’è un puntatore?</a>
</li><li>	<a href="#Operatore &"">/Operatore &</a>
</li><li>	<a href="#La funzione scanf"">/La funzione scanf</a>
</li><li>	<a href="#Dereferenziazione di un puntatore"">/Dereferenziazione di un puntatore</a>
</li><li>	<a href="#Operazioni sui puntatori"">/Operazioni sui puntatori</a>
</li><li>	<a href="#Aritmetica dei puntatori"">/Aritmetica dei puntatori</a>
</li><li>	<a href="#Funzione sizeof e dimensioni di memoria"">/Funzione sizeof e dimensioni di memoria</a>
</li><li>	<a href="#Puntatori a struct"">/Puntatori a struct</a>
</li><li>	<a href="#Array e puntatori"">/Array e puntatori</a>
<ul><li>		<a href="#Gli array nella memoria centrale"">/Gli array nella memoria centrale</a>
</li><li>		<a href="#Usare gli array come puntatori"">/Usare gli array come puntatori</a>
</li><li>		<a href="#Funzioni e puntatori"">/Funzioni e puntatori</a>
</li><li>		<a href="#Puntatori come parametri"">/Puntatori come parametri</a>
</li></ul></li></ul></li><li><a href="#Gestione dei file in C"">/Gestione dei file in C</a>
<ul><li>	<a href="#Memoria di massa e memoria centrale"">/Memoria di massa e memoria centrale</a>
</li><li>	<a href="#File come flussi"">/File come flussi</a>
</li><li>	<a href="#Apertura e chiusura di un file"">/Apertura e chiusura di un file</a>
</li><li>	<a href="#Modalità di apertura di un file"">/Modalità di apertura di un file</a>
</li><li>	<a href="#Operazioni di lettura e scrittura"">/Operazioni di lettura e scrittura</a>
<ul><li>		<a href="#Lettura e scrittura formattata"">/Lettura e scrittura formattata</a>
</li><li>		<a href="#Lettura e scrittura di un carattere"">/Lettura e scrittura di un carattere</a>
</li><li>		<a href="#Lettura e scrittura di stringhe"">/Lettura e scrittura di stringhe</a>
</li><li>		<a href="#Operazione di gestione degli errori"">/Operazione di gestione degli errori</a>
</li><li>		<a href="#Lettura e scrittura per blocchi"">/Lettura e scrittura per blocchi</a>
</li></ul></li><li>	<a href="#Accesso diretto"">/Accesso diretto</a>
<ul><li>		<a href="#Spostare l’indicatore di posizione corrente di un file"">/Spostare l’indicatore di posizione corrente di un file</a>
</li><li>		<a href="#Riavvolgere un file"">/Riavvolgere un file</a>
</li><li>		<a href="#Capire dove si trova al momento l’indicatore di posizione"">/Capire dove si trova al momento l’indicatore di posizione</a>
</li></ul></li><li>	<a href="#File e sistema operativo"">/File e sistema operativo</a>
</li><li>	<a href="#File e programmi in C"">/File e programmi in C</a>
</li><li>	<a href="#Struttura della tabella dei file aperti"">/Struttura della tabella dei file aperti</a>
</li></ul></li><li><a href="#Parametri a riga di comando"">/Parametri a riga di comando</a>
<ul><li>	<a href="#Utilizzare gli argomenti in C"">/Utilizzare gli argomenti in C</a>
</li></ul>
</li></ul>
<hr>
<h2 id="Primo programma in C">Primo programma in C</h2>
<pre><code class='code-multiline' lang='c'><span class="sf_code_comment">/* Commento
multilinea */</span>

<span class="sf_code_comment">//Commento singola linea</span>

<span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Hello world\n"</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
</code></pre><ul><li><b>Librerie</b>: insiemi di funzioni; possono essere chiamate ed <i>incluse</i> grazie al comando <code class='code-inline'>#include</code>
</li><li>Ogni programma in C deve avere una <b>funzione principale</b> <code class='code-inline'>main()</code> in cui viene eseguito tutto il codice
</li><li>La linea <code class='code-inline'>return 0;</code> <i>ritorna</i> il valore 0, che indica che il programma è stato eseguito correttamente e senza errori
</li><li>I <b>commenti</b> sono parti di codice che vengono deliberatamente <i>ignorate</i> dal compilatore, perciò possono essere molto utili per etichettare parti del codice e renderne chiaro lo scopo
</li></ul>
<hr>
<h2 id="Variabili">Variabili</h2>
<pre><code class='code-multiline' lang='c'><span class="sf_code_comment">// Programma Room3.c</span>
<span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">int</span> lung<span class="sf_code_punctuation">,</span> larg<span class="sf_code_punctuation">,</span> area<span class="sf_code_punctuation">;</span>
		lung <span class="sf_code_operator">=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span>
		larg <span class="sf_code_operator">=</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">;</span>
		area <span class="sf_code_operator">=</span> lung <span class="sf_code_operator">*</span> larg<span class="sf_code_punctuation">;</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"La mia stanza è lunga %d metri e larga %d metri\n"</span><span class="sf_code_punctuation">,</span>lung<span class="sf_code_punctuation">,</span>larg<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"La mia stanza è grande %d metri quadri\n"</span><span class="sf_code_punctuation">,</span>area<span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
</code></pre><b>Variabile</b>: spazio nella memoria del calcolatore cui viene assegnato un valore.
In C, la variabile va <i>dichiarata</i>: si dice al calcolatore il tipo di variabile e le si assegna un nome.
Nel programma possiamo <i>assegnare</i> un valore ad una variabile attraverso il simbolo <code class='code-inline'>=</code>. L’assegnazione funziona <b>da destra verso sinistra</b>, quindi non ha senso scrivere <code class='code-inline'>3 = lung;</code> per esempio, perché il compilatore si aspetta il nome di una variabile a sinistra dell’uguale.
Nel caso di questo programma, i valori delle variabili non sono assegnabili dall’utente, a meno che egli non abbia accesso al codice sorgente. Necessitiamo di un <i>input</i> da tastiera.
<hr>
<h2 id="Input da tastiera">Input da tastiera</h2>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">int</span> lung<span class="sf_code_punctuation">,</span> larg<span class="sf_code_punctuation">,</span> area<span class="sf_code_punctuation">;</span>

		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>lung<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>larg<span class="sf_code_punctuation">);</span>

		area <span class="sf_code_operator">=</span> lung <span class="sf_code_operator">*</span> larg<span class="sf_code_punctuation">;</span>

		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"La mia stanza è lunga %d metri e larga %d metri\n"</span><span class="sf_code_punctuation">,</span>lung<span class="sf_code_punctuation">,</span>larg<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"La mia stanza è grande %d metri quadri\n"</span><span class="sf_code_punctuation">,</span>area<span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
</code></pre><ul><li>I simboli <code class='code-inline'>%d</code> e simili sono dei <b>segnaposto</b> per dei valori. Grazie ad essi si possono specificare anche dei pattern particolari di input nel comando di input così: <code class='code-inline'>scanf("%d, %s, %f",&a,&b,&c);</code>
</li><li>L’operatore <code class='code-inline'>&</code> indica l’<b>assegnazione</b> del valore in input all’indirizzo di memoria della variabile specificata
</li></ul>
<hr>
<h2 id="Tipi di dati">Tipi di dati</h2>
<p><b>Tipi di dati Built-In</b></p>
<ul><li><code class='code-inline'>int</code>: numeri interi (usa la CPL2)
</li><li><code class='code-inline'>float</code>: numeri a virgola mobile, singola precisione (usa lo standard IEEE 754)
</li><li><code class='code-inline'>double</code>: numeri a virgola mobile, doppia precisione (usa lo standard IEEE 754)
</li><li><code class='code-inline'>char</code>: caratteri (1 byte, 0-255)
</li></ul>
<br>
<h3 id="Tipo int">Tipo int</h3>
<p>Rappresenta i numeri interi e ne esistono di più tipi:</p>
<ul><li><code class='code-inline'>short int</code> o <code class='code-inline'>short</code>: numeri interi di piccole dimensioni
</li><li><code class='code-inline'>long int</code> o <code class='code-inline'>long</code>: numeri interi di grandi dimensioni
</li><li><code class='code-inline'>unsigned</code>: intero <i>senza segno</i>, ossia solo positivo. Può raggiungere <b>valori assoluti più grandi</b> non avendo da rappresentare il segno
</li></ul>
<p>Si segue la seguente espressione per definire la differenza fra i tipi di <code class='code-inline'>int</code>:</p>
<p><code class='code-inline'>mem(short) &lt;= mem(int) &lt;= mem(long)</code></p>
<p>La quantità di memoria lasciata ai vari tipi di <code class='code-inline'>int</code> dipende da ogni compilatore, ma in genere:</p>
<ul><li>Sistema 32 bit: 2 byte per <code class='code-inline'>short</code> e 4 byte per <code class='code-inline'>int</code> e <code class='code-inline'>long</code>
</li><li>Sistema 64 bit: 2 byte per <code class='code-inline'>short</code>, 4 byte per <code class='code-inline'>int</code> ed 8 byte per <code class='code-inline'>long</code>
</li></ul>
<br>
<p>Esempi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Dichiarazione</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Inizializzazione</span>
<span class="sf_code_keyword">int</span> b <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">,</span> c <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_operator">/</span> Dichiarazione ed inizializzazione 

<span class="sf_code_keyword">int</span> max <span class="sf_code_operator">=</span> <span class="sf_code_number">2147483647</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore int</span>
<span class="sf_code_keyword">int</span> min <span class="sf_code_operator">=</span> <span class="sf_code_operator">-</span><span class="sf_code_number">2147483648</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Minimo valore int</span>

<span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">int</span> big <span class="sf_code_operator">=</span> <span class="sf_code_number">4294967295</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore unsigned</span>
<span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">int</span> err <span class="sf_code_operator">=</span> <span class="sf_code_operator">-</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore unsigned</span>

<span class="sf_code_keyword">short</span> <span class="sf_code_keyword">int</span> ooki <span class="sf_code_operator">=</span> <span class="sf_code_number">32767</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore short int</span>
<span class="sf_code_keyword">short</span> <span class="sf_code_keyword">int</span> smol <span class="sf_code_operator">=</span> <span class="sf_code_operator">-</span><span class="sf_code_number">32768</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Minimo valore short int </span>

<span class="sf_code_keyword">short</span> <span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">int</span> <span class="sf_code_operator">=</span> <span class="sf_code_number">65535</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore short unsigned </span>

<span class="sf_code_keyword">long</span> <span class="sf_code_keyword">int</span> biggus <span class="sf_code_operator">=</span> <span class="sf_code_number">4294967295</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Massimo valore big int </span>
<span class="sf_code_keyword">long</span> <span class="sf_code_keyword">int</span> smollest <span class="sf_code_operator">=</span> <span class="sf_code_operator">-</span><span class="sf_code_number">4294967296</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Minimo valore big int </span></code></pre>
<p><br></p>
<p>Tipi di operazioni:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">,</span>b <span class="sf_code_operator">=</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">,</span>c <span class="sf_code_operator">=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span>

a <span class="sf_code_operator">=</span> b <span class="sf_code_operator">+</span> c <span class="sf_code_operator">+</span> <span class="sf_code_number">10</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Addizione </span>
a <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>b <span class="sf_code_operator">+</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">)</span> <span class="sf_code_operator">*</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Addizione e moltiplicazione </span>
a <span class="sf_code_operator">=</span> <span class="sf_code_number">4</span> <span class="sf_code_operator">+</span> b <span class="sf_code_operator">-</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Addizione e sottrazione </span>
a <span class="sf_code_operator">=</span> b <span class="sf_code_operator">/</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Divisione intera </span>
a <span class="sf_code_operator">=</span> b <span class="sf_code_operator">%</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Resto della divisione intera </span></code></pre>
<p><br></p>
<p>Abbreviazioni:</p>
<pre><code class='code-multiline' lang='c'>a <span class="sf_code_operator">+=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a + 3 </span>
a <span class="sf_code_operator">-=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a - 3 </span>
a <span class="sf_code_operator">*=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a * 3 </span>
a <span class="sf_code_operator">/=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a / 3 </span>

a<span class="sf_code_operator">++</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a + 1 </span>
a<span class="sf_code_operator">--</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = a - 1 </span></code></pre>
<p><br></p>
<p>Segnaposti:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">int</span> u<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">short</span> s<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">short</span> us<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">long</span> l<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">unsigned</span> <span class="sf_code_keyword">long</span> ul<span class="sf_code_punctuation">;</span>

<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>i<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Intero </span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%u"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>u<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Intero unsigned </span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>s<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Short </span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%u"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>us<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Short unsigned </span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%ld"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Long </span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%lu"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>ul<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Long unsigned </span></code></pre>
<p><br></p>
<h3 id="Tipo float">Tipo float</h3>
<p>I due tipi di dati per numeri reali <i>built-in</i> nel linguaggio C sono il <code class='code-inline'>float</code> ed il <code class='code-inline'>double</code>, che corrispondono a <i>single precision</i> e <i>double precision</i> nello standard IEEE 754-1985.</p>
<p>La quantità di memoria usata per le variabili dipende dall’architettura del calcolatore usato.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_comment">// Floating point </span>

<span class="sf_code_keyword">float</span> f1 <span class="sf_code_operator">=</span> <span class="sf_code_number">1.045</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> f2 <span class="sf_code_operator">=</span> <span class="sf_code_number">.855</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> f3 <span class="sf_code_operator">=</span> <span class="sf_code_number">4.5567e3</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Notazione scientifica </span>
<span class="sf_code_keyword">float</span> f4 <span class="sf_code_operator">=</span> <span class="sf_code_number">4.53e-2</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Notazione scientifica </span>

<span class="sf_code_comment">// Double precision </span>

<span class="sf_code_keyword">double</span> d1 <span class="sf_code_operator">=</span> <span class="sf_code_number">.0005</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">double</span> d2 <span class="sf_code_operator">=</span> <span class="sf_code_operator">-</span><span class="sf_code_number">4.3e50</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Precisione molto maggiore </span>
<span class="sf_code_keyword">double</span> d3 <span class="sf_code_operator">=</span> <span class="sf_code_number">4.2e-78</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Precisione molto maggiore </span>
</code></pre><b>Nota</b>: nell’assegnare delle costanti reali, il C le memorizza come <code class='code-inline'>double</code>, quindi nel calcolare quella costante con un <code class='code-inline'>float</code> o nel convertire la costante a <code class='code-inline'>float</code> verranno persi 16 bit di precisione. Per specificare che una costante è di tipo <code class='code-inline'>float</code> basta aggiungere una <i>f</i> in fondo al valore: <code class='code-inline'>const PI = 3.14f;</code>.

Operazioni aritmetiche:
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">,</span>b <span class="sf_code_operator">=</span> <span class="sf_code_number">5.3</span><span class="sf_code_punctuation">,</span>c <span class="sf_code_operator">=</span> <span class="sf_code_number">3.2</span><span class="sf_code_punctuation">;</span>

a <span class="sf_code_operator">=</span> b <span class="sf_code_operator">+</span> c <span class="sf_code_operator">+</span> <span class="sf_code_number">.4</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Addizione</span>
a <span class="sf_code_operator">=</span> b <span class="sf_code_operator">*</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Moltiplicazione</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_number">4</span> <span class="sf_code_operator">+</span> b <span class="sf_code_operator">-</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Addizione e sottrazione</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>b <span class="sf_code_operator">-</span> <span class="sf_code_number">0.3</span><span class="sf_code_punctuation">)</span> <span class="sf_code_operator">/</span> <span class="sf_code_punctuation">(</span>c <span class="sf_code_operator">+</span> <span class="sf_code_number">0.8</span><span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Divisione, sottrazione ed addizione</span>

<span class="sf_code_keyword">float</span> x<span class="sf_code_punctuation">,</span>y<span class="sf_code_punctuation">,</span>z<span class="sf_code_punctuation">;</span>

z <span class="sf_code_operator">=</span> x <span class="sf_code_operator">/</span> y<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Il risultato sarà decimale</span>

<span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">,</span>m<span class="sf_code_punctuation">;</span>

z <span class="sf_code_operator">=</span> n <span class="sf_code_operator">/</span> m<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Il risultato sarà intero</span></code></pre>
<p><br></p>
<h3 id="Tipo char">Tipo char</h3>
<p>Viene rappresentato attraverso un solo byte e contiene la codifica numerica di un carattere, ossia un valore numerico nell’intervallo tra 0 e 255 compresi.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">char</span> a<span class="sf_code_punctuation">,</span>b<span class="sf_code_punctuation">,</span>c <span class="sf_code_operator">=</span> <span class="sf_code_string">'q'</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// I caratteri si indicano negli apici (')</span>

a <span class="sf_code_operator">=</span> <span class="sf_code_string">"q"</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Errore: "q" è una stringa</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_string">'\n'</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Corretto</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_string">'ps'</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Errore: sarebbe una stringa, non un carattere</span>

a <span class="sf_code_operator">=</span> <span class="sf_code_number">75</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Corretto: sarà inserito il carattere con valore 75</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_string">'c'</span> <span class="sf_code_operator">+</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Carattere 'd'</span>
a <span class="sf_code_operator">=</span> <span class="sf_code_string">'c'</span> <span class="sf_code_operator">-</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Carattere 'b'</span>

a <span class="sf_code_operator">=</span> <span class="sf_code_number">20</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = 20</span>
a <span class="sf_code_operator">*=</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = 80</span>
a <span class="sf_code_operator">-=</span> <span class="sf_code_number">10</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// a = 70 - Corrisponde ad 'F'</span></code></pre>
<p><br></p>
<p>Lettura e scrittura:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">char</span> c<span class="sf_code_punctuation">;</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire un carattere: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%c"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>c<span class="sf_code_punctuation">);</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nIl carattere inserito è %c\n"</span><span class="sf_code_punctuation">,</span>c<span class="sf_code_punctuation">);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span>"La sua codifica numerica è <span class="sf_code_operator">%</span>d\n<span class="sf_code_punctuation">,</span>c<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<h3 id="Tipo enum">Tipo enum</h3>
<p>Consente di elencare una sequenza di valori simbolici che la variabile può assumere. I valori vengono codificati come interi a partire da zero.</p>
<p>Non è un vero e proprio tipo di dato nuovo perché utilizza interi, ma permette di dare nomi ai vari valori che posso voler assegnare in futuro alla mia variabile.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">enum</span> <span class="sf_code_punctuation">{</span>falso<span class="sf_code_punctuation">,</span> vero<span class="sf_code_punctuation">}</span> condizione1<span class="sf_code_punctuation">,</span> condizione2<span class="sf_code_punctuation">;</span>

condizione1 <span class="sf_code_operator">=</span> falso<span class="sf_code_punctuation">;</span>
condizione2 <span class="sf_code_operator">=</span> vero<span class="sf_code_punctuation">;</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"condizione1 = %d\n"</span><span class="sf_code_punctuation">,</span>condizione1<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Stampa 0</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"condizione2 = %d\n"</span><span class="sf_code_punctuation">,</span>condizione2<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Stampa 1</span></code></pre>
<p><br></p>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">enum</span><span class="sf_code_punctuation">{</span>lun<span class="sf_code_punctuation">,</span> mar<span class="sf_code_punctuation">,</span> mer<span class="sf_code_punctuation">,</span> gio<span class="sf_code_punctuation">,</span> ven<span class="sf_code_punctuation">,</span> sab<span class="sf_code_punctuation">,</span> dom<span class="sf_code_punctuation">}</span> giorno<span class="sf_code_punctuation">;</span>

giorno <span class="sf_code_operator">=</span> mar<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Il valore assegnato alla variabile nella memoria del calcolatore sarà 1 (intero)</span></code></pre>
<p><br></p>
<h3 id="Ridefinizione di tipo">Ridefinizione di tipo</h3>
<p>Crea un alias di un tipo di dato.</p>
<p>Sintassi: <code class='code-inline'>typedef int newName</code></p>
<p>Rende più semplice cambiare tipo di variabile in un programma intero, poiché basta cambiare il tipo in <code class='code-inline'>typedef</code>.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">enum</span><span class="sf_code_punctuation">{</span>lun<span class="sf_code_punctuation">,</span>mar<span class="sf_code_punctuation">,</span>mer<span class="sf_code_punctuation">,</span>gio<span class="sf_code_punctuation">,</span>ven<span class="sf_code_punctuation">,</span>sab<span class="sf_code_punctuation">,</span>dom<span class="sf_code_punctuation">}</span> giorno<span class="sf_code_punctuation">;</span>
giorno oggi<span class="sf_code_punctuation">;</span>
oggi <span class="sf_code_operator">=</span> gio<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">int</span> colore<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Intero perché si usano i codici RAL</span>
colore coloreMacchina<span class="sf_code_punctuation">;</span>
coloreMacchina <span class="sf_code_operator">=</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<h3 id="Costanti">Costanti</h3>
<p>Il loro valore non cambia e non può essere cambiato durante l’esecuzione.</p>
<p>Si definiscono in due modi:</p>
<p><code class='code-inline'>const type name = value;</code> oppure <code class='code-inline'>#define name value</code>.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>
<span class="sf_code_macro">#define vero 1 </span><span class="sf_code_comment">// Specie di definizione di simbolo che viene poi sostituito</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_constant">const</span> <span class="sf_code_keyword">int</span> falso <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Variabile con valore che non può essere cambiato</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Conversioni di tipo">Conversioni di tipo</h3>
<p>Il C è un linguaggio con <b>forte tipizzazione</b>: bisogna sempre dichiarare il tipo delle variabili. Il C consente di eseguire espressioni ed assegnazioni solo se le variabili coinvolte hanno tipi compatibili.</p>
<p>Nel caso di espressioni aritmetiche, se gli operandi sono di tipo diverso, il tipo inferiore viene convertito temporaneamente ad un tipo superiore per garantire che non vi siano perdite di informazione:</p>
<p><code class='code-inline'>int &lt; long &lt; unsigned long &lt; float &lt; double</code></p>
<p>Se necessario, è possibile effettuare una <b>conversione esplicita</b>, detta <i>cast</i>: <code class='code-inline'>(tipo) &lt;espressione&gt;</code></p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> x<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> y <span class="sf_code_operator">=</span> x <span class="sf_code_operator">/</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> y <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">((</span><span class="sf_code_keyword">float</span><span class="sf_code_punctuation">)</span> x<span class="sf_code_punctuation">)</span> <span class="sf_code_operator">/</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Cast corretto</span></code></pre>
<p><br></p>
<h3 id="Funzione sizeof">Funzione sizeof</h3>
<p>Con questa funzione si può trovare la dimensione di memoria allocata ad un tipo di variabile in byte.</p>
<p>Sintassi: <code class='code-inline'>sizeof(type)</code></p>
<hr>
<h2 id="Istruzioni condizionali">Istruzioni condizionali</h2>
<p>Sono istruzioni che servono a <i>prendere delle scelte</i> durante l’esecuzione di un programma ed a cambiare il percorso seguito da esso.</p>
<br>
<h3 id="If statement">If statement</h3>
<p>Istruzione condizionale base</p>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>condition<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		statement<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
</code></pre>Semantica: lo statement viene eseguito <b>solo se</b> la condizione è vera.

<h3 id="Vero e falso in C">Vero e falso in C</h3>
In C non c’è un tipo di dato specifico per rappresentare i concetti di vero e falso. Una condizione assume un valore intero pari a:
<ul><li>0 se la condizione è falsa
</li><li>1 se la condizione è vera
</li></ul>
<p>In generale, <b>ogni valore diverso da 0 è considerato vero</b>.</p>
<br>
<h3 id="Operatori relazionali">Operatori relazionali</h3>
<p>Operano su valori numerici e di carattere e possono essere espressioni aritmetiche, variabili o costanti.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_operator">&gt;</span>  <span class="sf_code_comment">// Maggiore</span>
<span class="sf_code_operator">&lt;</span>  <span class="sf_code_comment">// Minore</span>
<span class="sf_code_operator">==</span> <span class="sf_code_comment">// Uguale</span>
<span class="sf_code_operator">&lt;=</span> <span class="sf_code_comment">// Miniore o uguale</span>
<span class="sf_code_operator">&gt;=</span> <span class="sf_code_comment">// Maggiore o uguale</span>
<span class="sf_code_operator">!=</span> <span class="sf_code_comment">// Diverso</span></code></pre>
<p><br></p>
<h3 id="Operatori logici">Operatori logici</h3>
<p>Consentono di costruire condizioni complesse a partire da condizioni più semplici e sono quattro:</p>
<ul><li>AND (Binario)
</li><li>OR (Binario)
</li><li>NOT (Unario)
</li><li>XOR (Binario)
</li></ul>
<p>Possono essere definiti in maniera univoca con la <b>tavola della verità</b>:</p>
<ul><li><b>Operatori binari</b>
</li></ul>
<p><img src='Introduzione%20al%20C/image_2020-09-30_14-07-27.png'></p>
<ul><li><b>Operatore unario NOT</b>
</li></ul>
<p><img src='Introduzione%20al%20C/image_2020-09-30_14-07-40.png'></p>
<p>Nel linguaggio C, la sintassi degli operatori logici è:</p>
<pre><code class='code-multiline' lang='c'>condition <span class="sf_code_operator">&&</span> condition <span class="sf_code_comment">//AND</span>
condition <span class="sf_code_operator">||</span> condition <span class="sf_code_comment">//OR</span>
<span class="sf_code_operator">!</span>condition <span class="sf_code_comment">//NOT</span></code></pre>
<p><br></p>
<h3 id="Ordine tra gli operatori">Ordine tra gli operatori</h3>
<p>Un’espressione viene valutata nel seguente ordine:</p>
<ol start="1"><li>Operatori <code class='code-inline'>++</code> e <code class='code-inline'>--</code>
</li><li>Operatore <code class='code-inline'>!</code>
</li><li>Operatori aritmetici
</li><li>Operatori relazionali
</li><li>Operatore <code class='code-inline'>&&</code>
</li><li>Operatore <code class='code-inline'>||</code>
</li></ol>
<p>È possibile utilizzare le parentesi tonde per specificare la precedenza desiderata.</p>
<p>Non si possono usare altri tipi di parentesi per questo scopo, ma sono consentiti vari livelli di parentesi tonde annidati.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">int</span> anni<span class="sf_code_punctuation">,</span>cc<span class="sf_code_punctuation">,</span>giovane<span class="sf_code_punctuation">,</span>altaCC<span class="sf_code_punctuation">;</span>

		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire l'età: "</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>anni<span class="sf_code_punctuation">);</span>
		giovane <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>anni <span class="sf_code_operator">&lt;=</span> <span class="sf_code_number">20</span><span class="sf_code_punctuation">);</span>
		altaCC <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>cc<span class="sf_code_operator">&gt;</span><span class="sf_code_number">1400</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>giovane <span class="sf_code_operator">&&</span> altaCC<span class="sf_code_punctuation">)</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Incremento: 70\%\n"</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>giovane <span class="sf_code_operator">&&</span> <span class="sf_code_operator">!</span>altaCC<span class="sf_code_punctuation">)</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Incremento: 40\%\n"</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span><span class="sf_code_operator">!</span>giovane <span class="sf_code_operator">&&</span> altaCC<span class="sf_code_punctuation">)</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Incremento: 10\%\n"</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span><span class="sf_code_operator">!</span>giovane <span class="sf_code_operator">&&</span> <span class="sf_code_operator">!</span>altaCC<span class="sf_code_punctuation">)</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Incremento: nessuno\n"</span><span class="sf_code_punctuation">);</span>

		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="If - else statement">If - else statement</h3>
<p>Consente di scegliere fra due alternative nel flusso di esecuzione</p>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>condition<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		statement<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Esegue questa se condition == vera</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_keyword">else</span>
	<span class="sf_code_punctuation">{</span>
		statement<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Esegue questa se condition == falsa</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Esempio concreto:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">char</span> c<span class="sf_code_punctuation">;</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire il carattere maiuscolo: "</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\n%c"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>c<span class="sf_code_punctuation">);</span>
		
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>c<span class="sf_code_operator">&gt;=</span><span class="sf_code_string">'A'</span> <span class="sf_code_operator">&&</span> c <span class="sf_code_operator">&lt;=</span><span class="sf_code_string">'Z'</span><span class="sf_code_punctuation">)</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nLa traduzione è %c\n"</span><span class="sf_code_punctuation">,</span>c<span class="sf_code_operator">+</span><span class="sf_code_number">32</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">else</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nIl carattere inserito non è maiuscolo\n"</span><span class="sf_code_punctuation">);</span>

		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Statement composti">Statement composti</h3>
<p>Scrivere un programma che, letti due numeri, individua quello maggiore e quello minore</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">float</span> max<span class="sf_code_punctuation">,</span> min<span class="sf_code_punctuation">,</span> temp<span class="sf_code_punctuation">;</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nInserire il primo numero: "</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>max<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nInserire il secondo numero: "</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>min<span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>max<span class="sf_code_operator">&lt;</span>min<span class="sf_code_punctuation">)</span>
			<span class="sf_code_punctuation">{</span> <span class="sf_code_comment">//Se ci sono più istruzioni, vanno racchiuse nelle graffe</span>
				temp <span class="sf_code_operator">=</span> min<span class="sf_code_punctuation">;</span>
				min <span class="sf_code_operator">=</span> max<span class="sf_code_punctuation">;</span>
				max <span class="sf_code_operator">=</span> temp<span class="sf_code_punctuation">;</span>
			<span class="sf_code_punctuation">}</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nmax = %f - min = %f\n"</span><span class="sf_code_punctuation">,</span>max<span class="sf_code_punctuation">,</span>min<span class="sf_code_punctuation">);</span>
		
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Switch statement">Switch statement</h3>
<p>Serve a scegliere fra varie opzioni simili in modo più veloce.</p>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">switch</span> <span class="sf_code_punctuation">(</span>expression<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">case</span> expression<span class="sf_code_punctuation">:</span> <span class="sf_code_comment">// Quanti se ne vogliono</span>
		<span class="sf_code_operator">&lt;</span>code<span class="sf_code_operator">&gt;</span>
		<span class="sf_code_keyword">break</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">// Esce dal blocco switch</span>
		<span class="sf_code_punctuation">[...]</span>
		<span class="sf_code_keyword">default</span><span class="sf_code_punctuation">:</span> <span class="sf_code_comment">// Nessuna condizione soddisfatta nei casi </span>
		<span class="sf_code_operator">&lt;</span>code<span class="sf_code_operator">&gt;</span>
	<span class="sf_code_punctuation">}</span>
</code></pre><hr>
<h2 id="Cicli">Cicli</h2>
Servono a ripetere le stesse istruzioni più volte.

<h3 id="Ciclo for">Ciclo for</h3>
Sintassi:
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span> initialization <span class="sf_code_punctuation">;</span> condition <span class="sf_code_punctuation">;</span> update <span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		statement1<span class="sf_code_punctuation">;</span>
		statement2<span class="sf_code_punctuation">;</span>
		statement3<span class="sf_code_punctuation">;</span>
		<span class="sf_code_punctuation">[...]</span>
		statementN<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Ciclo while">Ciclo while</h3>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span>condition<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		body
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Ciclo do-while">Ciclo do-while</h3>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">do</span>
	<span class="sf_code_punctuation">{</span>
		body
	<span class="sf_code_punctuation">}</span> <span class="sf_code_keyword">while</span> <span class="sf_code_punctuation">(</span>condition<span class="sf_code_punctuation">)</span></code></pre>
<p><br></p>
<h3 id="Istruzioni break e continue">Istruzioni break e continue</h3>
<ul><li>L’istruzione <code class='code-inline'>break</code> interrompe l’esecuzione del ciclo
</li><li>L’istruzione <code class='code-inline'>continue</code> passa direttamente all’iterazione seguente
</li></ul>
<hr>
<h2 id="Funzioni in C">Funzioni in C</h2>
<h3 id="Funzioni senza parametri o ritorno">Funzioni senza parametri o ritorno</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">func</span><span class="sf_code_punctuation">()</span>
	<span class="sf_code_punctuation">{</span>
		body
	<span class="sf_code_punctuation">}</span>
</code></pre>Richiamo della funzione: <code class='code-inline'>func();</code>

<h3 id="Funzioni con parametri">Funzioni con parametri</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">func</span><span class="sf_code_punctuation">(</span>type1 par1<span class="sf_code_punctuation">,</span> type2 par2<span class="sf_code_punctuation">)</span> <span class="sf_code_comment">// Parametri formali</span>
	<span class="sf_code_punctuation">{</span>
		body
	<span class="sf_code_punctuation">}</span>
</code></pre>Richiamo della funzione: <code class='code-inline'>func(val1, val2) // Parametri attuali</code>
I parametri attuali vengono assegnati ai parametri formali alla chiamata della funzione.

<h3 id="Funzioni con valori di ritorno">Funzioni con valori di ritorno</h3>
<pre><code class='code-multiline' lang='c'>type <span class="sf_code_function">func</span><span class="sf_code_punctuation">(</span>type1 par1<span class="sf_code_punctuation">,</span> type2 par2<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		body

		<span class="sf_code_keyword">return</span> returnValue<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Dichiarazione di una funzione">Dichiarazione di una funzione</h3>
<p>La dichiarazione del <i>prototipo</i> (o <i>signature</i>) di una funzione specifica <b>nome</b>, <b>tipo di valore</b> e <b>parametri</b> della funzione stessa.</p>
<p><code class='code-inline'>type funcName(parameters);</code></p>
<p>Serve ad informare il compilatore che quella funzione sarà usata nel programma.</p>
<p>La dichiarazione del prototipo deve <i>precedere</i> il punto in cui la funzione viene richiamata. Abitualmente, le dichiarazioni vengono posizionate in cima al programma, <i>prima</i> della funzione <code class='code-inline'>main()</code>.</p>
<br>
<h3 id="Definizione di una funzione">Definizione di una funzione</h3>
<p>La definizione specifica <i>sia il prototipo che la sequenza di istruzioni</i> contenute nella funzione.</p>
<pre><code class='code-multiline' lang='c'>type <span class="sf_code_function">funcName</span><span class="sf_code_punctuation">(</span>parameters<span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		body
	<span class="sf_code_punctuation">}</span>
</code></pre>La funzione può essere definita ovunque nel programma. Se la definizione viene definita <i>prima</i> del punto in cui la funzione viene richiamata per la prima volta, la dichiarazione <b>può essere omessa</b>.
Per semplicità, si consiglia di utilizzare le dichiarazioni dei prototipi prima della funzione <code class='code-inline'>main()</code> e definire le suddette funzioni <i>dopo</i> alla funzione <code class='code-inline'>main()</code>.

<h3 id="Visibilità delle variabili - Scoping">Visibilità delle variabili - Scoping</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> p<span class="sf_code_punctuation">);</span>

<span class="sf_code_keyword">float</span> g<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>a <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> a <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> a<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">int</span> b<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> p<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> c<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>
</code></pre><b>In quali parti del programma sono visibili le variabili g, a, b, c e p?</b>
Regole di <b>scoping</b> in C:
<ul><li>Ogni area racchiusa fra <code class='code-inline'>{}</code> costituisce un <b>blocco</b>
</li><li>Le variabili dichiarate all’interno di un blocco sono dette <b>locali</b> e sono visibili solo all’interno di quel blocco
</li><li>Le variabili dichiarate all’esterno di tutti i blocchi, ossia dichiarate all’interno del <b>blocco globale</b>, sono dette variabili <b>globali</b> e sono visibili ovunque all’interno del programma
</li><li>Se due variabili sono dichiarate con lo stesso nome ma in blocchi diversi, la regola generale è che la variabile locale <b>oscura</b> la variabile globale
</li></ul>
<br>
<h3 id="Vita di una variabile">Vita di una variabile</h3>
<ul><li>Le variabili locali vengono <i>create</i> all’atto della loro dichiarazione dentro ad un blocco
</li><li>Quando l’esecuzione del blocco è terminata, tutte le variabili locali di quel blocco vengono <b>distrutte</b>
</li></ul>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>a <span class="sf_code_operator">!=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> x<span class="sf_code_punctuation">;</span>
	<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span>"<span class="sf_code_operator">%</span>d<span class="sf_code_operator">%</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>x<span class="sf_code_punctuation">);</span>
	x <span class="sf_code_operator">=</span> x <span class="sf_code_operator">/</span> a<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span> <span class="sf_code_comment">// Qui la variabile x viene distrutta</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span> x<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Errore</span></code></pre>
<p><br></p>
<ul><li>Le variabili locali che sono dichiarate con la parola chiave <code class='code-inline'>static</code> <b>mantengono il loro valore</b> tra l’esecuzione di un blocco ed il successivo
</li><li>L’inizializzazione di una variabile <code class='code-inline'>static</code> viene fatta, sempre e comunque, <b>una volta sola</b> nel programma.
</li></ul>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> ris<span class="sf_code_punctuation">,</span> i<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">static</span> <span class="sf_code_keyword">int</span> s <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	s<span class="sf_code_operator">++</span><span class="sf_code_punctuation">;</span>
	ris <span class="sf_code_operator">=</span> s<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d\n"</span><span class="sf_code_punctuation">,</span> ris<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">// Stampa i numeri da 1 a 5 correttamente</span></code></pre>
<p><br></p>
<h3 id="Regole di Scoping e funzioni">Regole di Scoping e funzioni</h3>
<ul><li>I parametri formali sono a tutti gli effetti variabili locali di una funzione e perciò seguono le regole già viste
</li><li>Le variabili globali sono visibili e <b>modificabili</b> all’interno di una funzione
</li><li>Questo comporta la possibilità di creare <i>effetti indesiderati</i> difficili da prevedere alla chiamata della funzione
</li><li>È opportuno limitare l’uso di variabili globali per evitare problemi inaspettati
</li><li>Viceversa, è meglio dichiarare statement <code class='code-inline'>typedef</code> e funzioni nel blocco globale, per essere poi utilizzabili nell’intero programma
</li></ul>
<hr>
<h2 id="Dati strutturati in C">Dati strutturati in C</h2>
<h2 id="Array">Array</h2>
<p>Offrono la possibilità di rappresentare in modo compatto una collezione di variabili.</p>
<p>Sintassi: <code class='code-inline'>float vendite[12]</code></p>
<ul><li>L’accesso ad un elemento avviene attraverso il nome dell’array seguito dalla posizione dell’elemento stesso fra parentesi quadre, il <b>subscript</b>
</li><li>La posizione deve essere intera o compatibile e parte da 0, fino alla dimensione dell’array meno uno
</li><li>Ogni singolo elemento dell’array è del tutto analogo ad una variabile di tipo semplice
</li></ul>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">12</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">float</span> totale <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">for</span> <span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">12</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	totale <span class="sf_code_operator">=</span> totale <span class="sf_code_operator">+</span> vendite<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span><span class="sf_code_operator">&</span>vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nLe vendite di Dicembre sono state: %f"</span><span class="sf_code_punctuation">,</span> vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">11</span><span class="sf_code_punctuation">]);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\nL'incremento è pari a %f\n"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_punctuation">(</span>vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">-</span> vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">])</span> <span class="sf_code_operator">/</span> vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]);</span></code></pre>
<p><br></p>
<p>È possibile inizializzare un array in fase di dichiarazione così:</p>
<p><code class='code-inline'>type name[N] = {val1, val2, ... ,valN};</code></p>
<p>Si può inizializzare a zero un array numerico nel seguente modo:</p>
<p><code class='code-inline'>float v[100] = {0};</code></p>
<p>In questo caso, il primo elemento di v è 0, e tutti gli altri vengono portati ad un valore di default, che in questo caso è sempre 0.</p>
<p>Nel caso <code class='code-inline'>float v[100] = {4};</code>, avremo il primo elemento con valore 4, mentre gli altri verranno inizializzati a 0 di default.</p>
<br>
<h3 id="Lettura e scrittura di un Array">Lettura e scrittura di un Array</h3>
<ul><li>La lettura e la scrittura avviene <b>un elemento alla volta</b>
</li><li>È molto conveniente usare il <b>ciclo for</b> per riempire e leggere gli array
</li></ul>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> prezzo<span class="sf_code_punctuation">[</span><span class="sf_code_number">4</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>prezzo<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]);</span>
<span class="sf_code_punctuation">}</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"prezzo[%d] = %f"</span><span class="sf_code_punctuation">,</span> i<span class="sf_code_punctuation">,</span> prezzo<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]);</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> vendite<span class="sf_code_punctuation">[</span><span class="sf_code_number">6</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">,</span> j<span class="sf_code_punctuation">;</span>

	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">6</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Vendite di %d mese/i fa: "</span><span class="sf_code_punctuation">,</span> i <span class="sf_code_operator">+</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>vendite<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]);</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&gt;=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">--</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">)</span> <span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d mesi fa "</span><span class="sf_code_punctuation">,</span> i <span class="sf_code_operator">+</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">else</span> <span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"1 mese fa: "</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>j <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> j <span class="sf_code_operator">&lt;</span> vendite<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">];</span> j<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_punctuation">{</span>
			<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"*"</span><span class="sf_code_punctuation">);</span>
		<span class="sf_code_punctuation">}</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"\n"</span><span class="sf_code_punctuation">);</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Range">Range</h3>
<p>In C è il programmatore a doversi preoccupare di non accedere a elementi dell’array non validi.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> prezzo<span class="sf_code_punctuation">[</span><span class="sf_code_number">4</span><span class="sf_code_punctuation">];</span>
prezzo<span class="sf_code_punctuation">[</span><span class="sf_code_number">4</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_number">42</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Non esiste un elemento 4 dell'array</span></code></pre>
<p><br></p>
<h3 id="Subscript">Subscript</h3>
<p>È possibile usare <code class='code-inline'>enum</code> e <code class='code-inline'>char</code> come subscript.</p>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">enum</span><span class="sf_code_punctuation">{</span>gen<span class="sf_code_punctuation">,</span> feb<span class="sf_code_punctuation">,</span> mar<span class="sf_code_punctuation">,</span> apr<span class="sf_code_punctuation">,</span> mag<span class="sf_code_punctuation">,</span> giu<span class="sf_code_punctuation">,</span> lug<span class="sf_code_punctuation">,</span> ago<span class="sf_code_punctuation">,</span> set<span class="sf_code_punctuation">,</span> ott<span class="sf_code_punctuation">,</span> nov<span class="sf_code_punctuation">,</span> dic<span class="sf_code_punctuation">}</span> mese<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> vendite <span class="sf_code_punctuation">[</span><span class="sf_code_number">12</span><span class="sf_code_punctuation">];</span>
mese m<span class="sf_code_punctuation">;</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Vendite di Aprile: %f\n"</span><span class="sf_code_punctuation">,</span> vendite<span class="sf_code_punctuation">[</span>apr<span class="sf_code_punctuation">]);</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>m <span class="sf_code_operator">=</span> gen<span class="sf_code_punctuation">;</span> m <span class="sf_code_operator">&lt;=</span> dic<span class="sf_code_punctuation">;</span> m<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>vendite<span class="sf_code_punctuation">[</span>m<span class="sf_code_punctuation">]);</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> freq<span class="sf_code_punctuation">[</span><span class="sf_code_number">26</span><span class="sf_code_punctuation">];</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"La frequenza della lettera f è: %f\n"</span><span class="sf_code_punctuation">,</span> freq<span class="sf_code_punctuation">[</span><span class="sf_code_string">'f'</span> <span class="sf_code_operator">-</span> <span class="sf_code_string">'a'</span><span class="sf_code_punctuation">]);</span></code></pre>
<p><br></p>
<h3 id="Copia e confronto di array">Copia e confronto di array</h3>
<p>La copia fra due array <b>non può essere fatta</b> tramite un semplice assegnamento:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">{</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">},</span> b<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">];</span>
b <span class="sf_code_operator">=</span> a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Errore, non funziona</span></code></pre>
<p><br></p>
<p>È necessario copiare <b>un elemento per volta</b>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	b<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> a<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">];</span></code></pre>
<p><br></p>
<p>Analogamente, non è possibile usare gli operatori di confronto con gli array, ma occorre effettuare il confronto un elemento per volta:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">],</span> b<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">],</span> i<span class="sf_code_punctuation">;</span>
a <span class="sf_code_operator">==</span> b<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Errore di sintassi</span>

<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	a<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]</span> <span class="sf_code_operator">==</span> b<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">];</span> <span class="sf_code_comment">//Un elemento per volta</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Array e funzioni">Array e funzioni</h3>
<p>È possibile utilizzare gli array come parametri di una funzione in C, tuttavia:</p>
<ul><li>Il passaggio dei parametri si basa sull’assegnamento e non è ammissibile effettuare un assegnamento fra array o fra array e variabili scalari
</li><li>L’uso degli array come parametri di funzione richiede uno strumento aggiuntivo: <b>i puntatori</b>
</li></ul>
<br>
<h2 id="Stringhe">Stringhe</h2>
<p>Gli array di tipo <code class='code-inline'>char</code> sono anche detti <i>stringhe</i>. Dal momento che sono molto usati, il C mette a disposizione funzioni specifiche per questo tipo di dato.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">char</span> nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">10</span><span class="sf_code_punctuation">];</span>

nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'A'</span><span class="sf_code_punctuation">;</span>
nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'n'</span><span class="sf_code_punctuation">;</span>
nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">2</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'n'</span><span class="sf_code_punctuation">;</span>
nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'a'</span><span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>Questo modo di assegnare i caratteri uno ad uno è poco efficiente. Un modo migliore sarebbe:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">char</span> stringa<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
stringa messaggio<span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>In C, le costanti di tipo stringa si rappresentano come una sequenza di caratteri racchiusi tra <code class='code-inline'>" "</code>. L’inizializzazione può avvenire in fase di dichiarazione:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">char</span> stringa<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
stringa messagio <span class="sf_code_operator">=</span> <span class="sf_code_string">"prova"</span><span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>La lettura e la scrittura di stringhe è particolarmente semplice:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">char</span> nome<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserisci il tuo nome: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%s"</span><span class="sf_code_punctuation">,</span> nome<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Per la lettura delle stringhe non bisogna anteporre & al nome della stringa</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Ciao %s!\n"</span><span class="sf_code_punctuation">,</span> nome<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<p>Con <code class='code-inline'>%s</code>, <code class='code-inline'>scanf</code> legge una stringa fino al primo spazio. Per leggere stringhe che includono uno spazio si utilizza la stringa di formato <code class='code-inline'>%[^\n]</code></p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserisci il tuo nome: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%[^\n]"</span><span class="sf_code_punctuation">,</span> nome<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<h3 id="Carattere terminatore">Carattere terminatore</h3>
<p>In C esiste un carattere speciale che indica <b>la fine di una stringa</b>: <code class='code-inline'>\0</code>. Questo carattere ha codice 0 nella tabella ASCII.</p>
<p>Quando la funzione <code class='code-inline'>printf</code> individua questo carattere speciale, <b>smette di stampare a video gli elementi della stringa</b>.</p>
<p>Tutte le funzioni standard di libreria del C gestiscono autonomamente la posizione e l’individuazione del carattere <code class='code-inline'>\0</code>. Nel caso però io voglia dichiarare ed inizializzare manualmente una stringa carattere per carattere, <b>devo aggiungere il carattere terminatore</b> alla fine della stringa.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">char</span> msg<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
msg<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'A'</span><span class="sf_code_punctuation">;</span>
msg<span class="sf_code_punctuation">[</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'B'</span><span class="sf_code_punctuation">;</span>
msg<span class="sf_code_punctuation">[</span><span class="sf_code_number">2</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_string">'\0'</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Senza questa inizializzazione, printf stamperebbe anche altri caratteri non prevedibili fino a stampare tutto l'array msg</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%s"</span><span class="sf_code_punctuation">,</span> msg<span class="sf_code_punctuation">);</span>
</code></pre>Spesso si tende ad aggiungere 1 alla dimensione dell’array stringa per lasciare spazio al carattere terminatore.

<h3 id="Copia e confronto di stringhe">Copia e confronto di stringhe</h3>
Le stringhe sono comunque array di <code class='code-inline'>char</code>, perciò hanno le stesse limitazioni discusse per gli array. Tuttavia esistono due funzioni definite nella libreria <code class='code-inline'>string.h</code> che facilitano le operazioni di copia e confronto.
<ul><li>Copia: <code class='code-inline'>strcpy(s1, s2); //Copia s2 in s1</code>
</li><li>Confronto: <code class='code-inline'>strcmp(s1, s2); //Ritorna 0 se s1 è uguale a s2</code>
</li></ul>
<br>
<h3 id="Stringhe e funzioni">Stringhe e funzioni</h3>
<p>È possibile utilizzare le stringhe come parametri di funzioni in C, ma poiché i parametri di una funzione si basano sull’assegnazione, servono i <b>puntatori</b> per utilizzare le stringhe come parametri.</p>
<br>
<h2 id="Matrici">Matrici</h2>
<p>Le matrici sono strutture dati bidimensionali e vengono rappresentati come <i>array di array</i>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">int</span> matrice<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>
matrice a<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">float</span> b<span class="sf_code_punctuation">[</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">];</span></code></pre>
<p><br></p>
<p>Accesso ad un elemento: <code class='code-inline'>b[1][0] = 30;</code></p>
<br>
<p>La lettura avviene <b>un elemento alla volta</b>, come per gli array:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>

<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>j <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> j <span class="sf_code_operator">&lt;</span> M<span class="sf_code_punctuation">;</span> j<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">][</span>j<span class="sf_code_punctuation">]);</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>La scrittura delle matrici è identica:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>

<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>j <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> j <span class="sf_code_operator">&lt;</span> M<span class="sf_code_punctuation">;</span> j<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%f"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">][</span>j<span class="sf_code_punctuation">]);</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>La somma fra matrici funziona in modo analogo:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">float</span> b<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">float</span> sum<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">][</span>M<span class="sf_code_punctuation">];</span>

<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>j <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> j <span class="sf_code_operator">&lt;</span> M<span class="sf_code_punctuation">;</span> j<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		sum<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">][</span>j<span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> a<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">][</span>j<span class="sf_code_punctuation">]</span> <span class="sf_code_operator">+</span> b<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">][</span>j<span class="sf_code_punctuation">];</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Inizializzazione manuale:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">2</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">{{</span><span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">},</span> <span class="sf_code_punctuation">{</span><span class="sf_code_number">4</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">6</span><span class="sf_code_punctuation">}},</span> b<span class="sf_code_punctuation">[</span><span class="sf_code_number">2</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">];</span>
b <span class="sf_code_operator">=</span> a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Errore di sintassi</span></code></pre>
<p><br></p>
<p>Analogamente agli array, non si possono utilizzare operatori di confronto con le matrici. I confronti vanno fatti <b>un elemento alla volta</b>.</p>
<br>
<h2 id="Struct">Struct</h2>
<p>Devo rappresentare i libri in una biblioteca, utilizzando delle variabili:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span></code></pre>
<p><br></p>
<p>Se i libri fossero tanti, questo tipo di soluzione non sarebbe praticabile. Inoltre, queste variabili così impostate non sono in alcun modo collegate tra loro.</p>
<p>Il problema si può affrontare usando le <code class='code-inline'>struct</code>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Campi</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span> libro1<span class="sf_code_punctuation">,</span> libro2<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Variabili</span></code></pre>
<p><br></p>
<p>Rispetto agli array, gli elementi non sono numerati ma hanno un <b>nome</b> e <b>possono essere di tipi diversi</b>.</p>
<p>Per accedere ad un campo di una struct si usa la sintassi <code class='code-inline'>var.campo</code>.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Campi</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span> l<span class="sf_code_punctuation">,</span> l2<span class="sf_code_punctuation">;</span>

l<span class="sf_code_punctuation">.</span>anno <span class="sf_code_operator">=</span> <span class="sf_code_number">1998</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Accesso al campo "anno" di "l"</span></code></pre>
<p><br></p>
<p>La lettura di una struct avviene <b>campo per campo</b>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire anno: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>l<span class="sf_code_punctuation">.</span>anno<span class="sf_code_punctuation">);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire numero pagine: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>l<span class="sf_code_punctuation">.</span>pagine<span class="sf_code_punctuation">);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire autore: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%[^\n]"</span><span class="sf_code_punctuation">,</span> l<span class="sf_code_punctuation">.</span>autore<span class="sf_code_punctuation">);</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Inserire titolo: "</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%[^\n]"</span><span class="sf_code_punctuation">,</span> l<span class="sf_code_punctuation">.</span>titolo<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<h3 id="Struct con nome e typedef">Struct con nome e typedef</h3>
<p>Con nome:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">struct</span> libro
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">struct</span> libro l<span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>Con <code class='code-inline'>typedef</code>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span> libro<span class="sf_code_punctuation">;</span>

libro l<span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>Solitamente in questo caso si pone la <code class='code-inline'>struct</code> nel blocco globale per poter creare variabili della <code class='code-inline'>struct</code> ovunque nel programma.</p>
<br>
<h3 id="Array di struct">Array di struct</h3>
<p>È possibile dichiarare un array di struct. In questo modo è possibile gestire una sequenza di elementi ognuno dei quali rappresenta un dato strutturato.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span> libro<span class="sf_code_punctuation">;</span>

libro biblioteca<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">];</span></code></pre>
<p><br></p>
<p>Esempio: leggere i dati di una biblioteca e trovare il libro più vecchio.</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>
<span class="sf_code_macro">#define N 3</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_punctuation">}</span> libro<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	libro biblioteca<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">,</span> oldest<span class="sf_code_punctuation">;</span>

	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>biblioteca<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">].</span>anno<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%d"</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>biblioteca<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">].</span>pagine<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%[^\n]"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">].</span>autore<span class="sf_code_punctuation">);</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"%[^\n]"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">].</span>titolo<span class="sf_code_punctuation">);</span>
	<span class="sf_code_punctuation">}</span>
	
	oldest <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>biblioteca<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">].</span>anno <span class="sf_code_operator">&lt;</span> biblioteca<span class="sf_code_punctuation">[</span>oldest<span class="sf_code_punctuation">].</span>anno<span class="sf_code_punctuation">)</span>
		<span class="sf_code_punctuation">{</span>
			vecchio <span class="sf_code_operator">=</span> i<span class="sf_code_punctuation">;</span>
		<span class="sf_code_punctuation">}</span>
	<span class="sf_code_punctuation">}</span>

	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Dati libro più vecchio\n"</span><span class="sf_code_punctuation">);</span>
	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Anno: %d\n"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>oldest<span class="sf_code_punctuation">].</span>anno<span class="sf_code_punctuation">);</span>
	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Numero pagine: %d\n"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>oldest<span class="sf_code_punctuation">].</span>pagine<span class="sf_code_punctuation">);</span>
	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Autore: %s\n"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>oldest<span class="sf_code_punctuation">].</span>autore<span class="sf_code_punctuation">);</span>
	<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"Titolo: %s\n"</span><span class="sf_code_punctuation">,</span> biblioteca<span class="sf_code_punctuation">[</span>oldest<span class="sf_code_punctuation">].</span>titolo<span class="sf_code_punctuation">);</span>

	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Assegnamento, confronto e funzioni con struct">Assegnamento, confronto e funzioni con struct</h3>
<p>Il C <b>permette di effettuare assegnamento fra struct</b> senza dover considerare un elemento alla volta:</p>
<pre><code class='code-multiline' lang='c'>libro l1<span class="sf_code_punctuation">,</span> l2<span class="sf_code_punctuation">;</span>
l1 <span class="sf_code_operator">=</span> l2<span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<p>Non è invece possibile effettuare confronti fra struct ma occorre considerare <b>un campo per volta</b>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l1 <span class="sf_code_operator">==</span> l2<span class="sf_code_punctuation">)</span> <span class="sf_code_comment">//Errore di sintassi</span></code></pre>
<p><br></p>
<p>Le struct <b>possono essere usate come parametri e valori di ritorno</b> delle funzioni senza particolari accorgimenti:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span>libro l<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<h3 id="Struct come campi">Struct come campi</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> anno<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> pagine<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span> edizione<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">char</span> autore<span class="sf_code_punctuation">[</span><span class="sf_code_number">30</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> titolo<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">char</span> editore<span class="sf_code_punctuation">[</span><span class="sf_code_number">100</span><span class="sf_code_punctuation">];</span>
	edizione edizioni<span class="sf_code_punctuation">[</span><span class="sf_code_number">10</span><span class="sf_code_punctuation">];</span>
	<span class="sf_code_keyword">int</span> edizioni<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span> libro<span class="sf_code_punctuation">;</span>

libro l<span class="sf_code_punctuation">;</span>
<span class="sf_code_comment">//l.edizioni[0].anno è la sintassi per accedere al campo edizioni e quindi alla struct edizione</span></code></pre>
<p><br></p>
<h2 id="Programmazione ricorsiva">Programmazione ricorsiva</h2>
<p>La <b>ricorsione</b> si ha quando una funzione <b>richiama se stessa</b> (ricorsione <i>diretta</i>) oppure <b>un’altra funzione</b> (ricorsione <i>indiretta</i>).</p>
<p>È una tecnica di programmazione molto potente che permette di risolvere in maniera elegante problemi complessi.</p>
<p>Per risolvere un problema con la programmazione ricorsiva sono necessari alcuni elementi:</p>
<ul><li><b>Caso base</b>: caso <i>elementare</i> del problema che può essere immediatamente risolto
</li><li><b>Passo ricorsivo</b>: chiamata ricorsiva per risolvere uno o più problemi più semplici
</li><li><b>Costruzione della soluzione</b>: costruzione della soluzione sulla base del risultato delle chiamate ricorsive
</li></ul>
<br>
<p>Esempio: <b>Calcolo del fattoriale</b></p>
<ul><li><b>Definizione</b>: <code class='code-inline'>f(n) = n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1</code>
</li><li><b>Passo ricorsivo</b>: <code class='code-inline'>f(n) = n * f(n - 1)</code>
</li><li><b>Caso base</b>: <code class='code-inline'>f(0) = 1</code>
</li><li><b>Risoluzione</b>:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">==</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Caso base</span>
	<span class="sf_code_keyword">else</span>
		<span class="sf_code_keyword">return</span> n <span class="sf_code_operator">*</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">-</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Passo ricorsivo</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Esempio: <b>Sequenza di Fibonacci</b></p>
<p>È una sequenza di numeri interi in cui ogni numero si ottiene sommando i due precedenti nella sequenza. I primi due numeri sono per definizione 1.</p>
<ul><li><b>Caso base</b>: <code class='code-inline'>f1 = 1</code>, <code class='code-inline'>f2 = 1</code>
</li><li><b>Passo ricorsivo</b>: <code class='code-inline'>fn = fn-1 + fn-2</code>
</li><li><b>Risoluzione</b>:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">fiboRic</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">==</span> <span class="sf_code_number">1</span> <span class="sf_code_operator">||</span> n <span class="sf_code_operator">==</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">else</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_function">fiboRic</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">-</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">)</span> <span class="sf_code_operator">+</span> <span class="sf_code_function">fiboRic</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">-</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Esempio: <b>Massimo Comune Divisore</b></p>
<p>Algoritmo di Euclide:</p>
<ul><li><b>Caso base</b>: se <code class='code-inline'>m = n</code>, <code class='code-inline'>MCD(m, n) = m</code>
</li><li><b>Caso ricorsivo</b>: se <code class='code-inline'>m &gt; n</code>, <code class='code-inline'>MCD(m, n) = MCD(m - n, n)</code>
</li><li><b>Caso ricorsivo</b>: se <code class='code-inline'>m &lt; n</code>, <code class='code-inline'>MCD(m, n) = MCD(m, n - m)</code>
</li><li><b>Risoluzione</b>:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">MCDEuclidRic</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> m<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>m <span class="sf_code_operator">==</span> n<span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> m<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">else</span> <span class="sf_code_keyword">if</span> <span class="sf_code_punctuation">(</span>m <span class="sf_code_operator">&gt;</span> n<span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_function">MCDEuclidRic</span><span class="sf_code_punctuation">(</span>m <span class="sf_code_operator">-</span> n<span class="sf_code_punctuation">,</span> n<span class="sf_code_punctuation">);</span>
	<span class="sf_code_keyword">else</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_function">MCDEuclidRic</span><span class="sf_code_punctuation">(</span>m<span class="sf_code_punctuation">,</span> n <span class="sf_code_operator">-</span> m<span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Problemi nell’uso della ricorsione">Problemi nell’uso della ricorsione</h3>
<ol start="1"><li>Errori nella ricorsione
</li></ol>
<p>Deve essere presente un caso base <i>sempre raggiungibile</i>.</p>
<br>
<p>Esempi:</p>
<ul><li>Loop infinito (argomento decrescente)
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">return</span> n <span class="sf_code_operator">*</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">-</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Non c'è il caso base</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<ul><li>Loop infinito (chiamate identiche)
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>n <span class="sf_code_operator">==</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">else</span> <span class="sf_code_keyword">return</span> <span class="sf_code_function">factRic</span><span class="sf_code_punctuation">(</span>n<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Manca il passo ricorsivo</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<ol start="2"><li>Uso della memoria
</li></ol>
<p>La programmazione ricorsiva comporta spesso un uso inefficiente della memoria per la gestione degli spazi di lavoro delle chiamate generate. In alcuni casi viene comunque preferita ad altri approcci per la sua eleganza e semplicità. In altri casi, si può ricorrere ad implementazioni iterative.</p>
<br>
<ul><li><b>Esempio</b>: funzione iterativa che calcola il numero n di Fibonacci:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">fibList</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> f1 <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> f2 <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> tmp<span class="sf_code_punctuation">,</span> i<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;=</span> n<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		tmp <span class="sf_code_operator">=</span> f2<span class="sf_code_punctuation">;</span>
		f2 <span class="sf_code_operator">=</span> f1 <span class="sf_code_operator">+</span> f2<span class="sf_code_punctuation">;</span>
		f1 <span class="sf_code_operator">=</span> tmp<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> f2<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<hr>
<h2 id="Puntatori">Puntatori</h2>
<p>Sono uno strumento che serve a gestire la memoria del calcolatore in maniera più approfondita. Per comprenderli bisogna capire meglio come funzioni la memoria di un calcolatore.</p>
<br>
<h3 id="Un modello “concettuale” della memoria">Un modello “concettuale” della memoria</h3>
<p>La memoria può essere rappresentata da una tabella con tante righe, le <b>celle di memoria</b>, di dimensione 8 bit, ognuna delle quali ha un <b>indirizzo</b> che la identifica, anch’esso rappresentato con dei bit.</p>
<p>Quando il calcolatore deve scrivere sulla memoria, dovrà scegliere un indirizzo di memoria in cui scrivere e poi memorizzare l’indirizzo per tornare a leggere quella cella.</p>
<p>Si possono fare delle stime su quanta memoria possa servire ad un programma. Se in ogni cella abbiamo un byte ed ho a disposizione 32 bit per rappresentare un indirizzo, allora abbiamo 2^32 byte di memoria a disposizione (circa 4 Gigabyte).</p>
<p>Non si può effettuare una scelta di quanti bit utilizzare computer per computer poiché è necessario che il programma che creo <b>funzioni a prescindere dal calcolatore</b>. Perciò la quantità di bit si sceglie a livello di <b>sistema operativo</b>: lo standard precedente era 32 bit, ora 64 bit.</p>
<br>
<h3 id="Variabili e memoria">Variabili e memoria</h3>
<p>Nella memoria entra tutto ciò che riguarda il nostro programma, in particolare le <b>variabili</b>. Non è compito nostro inserire una variabile nella memoria, noi ci limitiamo a darle un nome. Sono il compilatore ed il sistema operativo che decidono dove porre una variabile nella memoria. Con i puntatori, noi non possiamo scegliere l’indirizzo delle variabili ma potremo usare l’indirizzo di una variabile per <b>accedervi</b>.</p>
<p>Una cella di memoria ha dimensione 8 bit, ma esistono variabili, come abbiamo visto, che occupano più di 8 bit, come un float (che ne occupa 32). Il compilatore allora sceglie un indirizzo di memoria di partenza e riserverà <b>tutti gli indirizzi sequenziali necessari</b> ad ospitare quella variabile.</p>
<br>
<h3 id="Cos’è un puntatore?">Cos’è un puntatore?</h3>
<p>Un puntatore è un tipo di dato che viene usato in C per dichiarare una variabile che deve contenere un <b>indirizzo di cella di memoria</b>.</p>
<p>In gergo, si dice che la variabile <i>punta</i> alla cella di memoria, il cui indirizzo è contenuto nella variabile puntatore.</p>
<p>Quando viene dichiarata una variabile puntatore, è necessario anche specificare il tipo di dato contenuto nelle celle di memoria che verranno <i>puntate</i> alla variabile.</p>
<p>Sintassi: <code class='code-inline'>type *name;</code></p>
<br>
<h3 id="Operatore &">Operatore &</h3>
<p>Come si assegna un indirizzo di memoria di una variabile ad un puntatore?</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> var<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span>

var <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">;</span>
p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>var<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//&: “Indirizzo di...” - p “punta a” var</span>
</code></pre><code class='code-inline'>&</code> è un operatore unario e restituisce l’indirizzo di memoria di una variabile qualunque.

<h3 id="La funzione scanf">La funzione scanf</h3>
La funzione scanf ha come parametri la stringa di controllo e l’<b>indirizzo della variabile</b> in cui deve essere memorizzato il valore letto da tastiera.

<h3 id="Dereferenziazione di un puntatore">Dereferenziazione di un puntatore</h3>
Come accedere al <b>contenuto</b> della cella di memoria puntata dal puntatore:
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> var1<span class="sf_code_punctuation">,</span> var2<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span>

var1 <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">;</span>
p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>var1<span class="sf_code_punctuation">;</span>
var2 <span class="sf_code_operator">=</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p: indirizzo - *p: contenuto all’indirizzo p</span>
<span class="sf_code_operator">*</span>p <span class="sf_code_operator">=</span> <span class="sf_code_number">5.1</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Modifico il contenuto di var1</span></code></pre>
<p><br></p>
<h3 id="Operazioni sui puntatori">Operazioni sui puntatori</h3>
<ul><li>Inizializzazione: <code class='code-inline'>float *p = NULL;</code>
</li><li>Assegnamento fra puntatori:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p1 <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">*</span>p2 <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Non puntano a niente</span>
p1 <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p1 punta ad a ora</span>
p2 <span class="sf_code_operator">=</span> p1<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p2 punta anch’esso ad a</span>
</code></pre><ul><li>Assegnamento per dereferenziazione:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">,</span> b<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p1 <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">*</span>p2 <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
p1 <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p1 punta ad a</span>
p2 <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>b<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p2 punta a b</span>
<span class="sf_code_operator">*</span>p2 <span class="sf_code_operator">=</span> <span class="sf_code_operator">*</span>p1<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//b = a;</span></code></pre>
<p><br></p>
<h3 id="Aritmetica dei puntatori">Aritmetica dei puntatori</h3>
<p>Il C consente di effettuare somme e sottrazioni sui puntatori:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span>
<span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">;</span>
p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">;</span>

<span class="sf_code_operator">*</span><span class="sf_code_punctuation">(</span>p <span class="sf_code_operator">+</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">)</span> <span class="sf_code_operator">=</span> <span class="sf_code_number">4.5</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//p + 1 != x + 1</span>

<span class="sf_code_comment">/* p + 1 = x + (1 * dim),
dove dim è la dimensione in memoria del tipo associato al puntatore. Poiché p è un puntatore float, allora: dim = 4, perciò:
p + 1 = x + 4 */</span>

p <span class="sf_code_operator">=</span> p <span class="sf_code_operator">+</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//x + 8</span></code></pre>
<p><br></p>
<p>Sintassi: <code class='code-inline'>puntatore = puntatore + x</code></p>
<br>
<p>Semantica:</p>
<ul><li>Incrementa o decremento l’indirizzo contenuti nel puntatore di x <b>posizioni</b>
</li><li>La dimensione di ogni posizione dipende dal tipo di puntatore
</li></ul>
<br>
<h3 id="Funzione sizeof e dimensioni di memoria">Funzione sizeof e dimensioni di memoria</h3>
<p>Sintassi: <code class='code-inline'>sizeof(arg)</code></p>
<br>
<p>Se <code class='code-inline'>arg</code> è:</p>
<ul><li>Un <b>tipo di dato</b>: ritorna la quantità di memoria in byte necessaria per rappresentare un valore di quel tipo
</li><li>Una <b>variabile scalare</b>: ritorna la quantità di memoria in byte occupata da quella variabile
</li><li>Un <b>array</b>: ritorna la quantità di memoria in byte occupata dall’intero array
</li></ul>
<br>
<h3 id="Puntatori a struct">Puntatori a struct</h3>
<p>L’espressione <code class='code-inline'>(*p).campo</code> ha la stessa funzione dell’espressione <code class='code-inline'>p-&gt;campo</code></p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> x<span class="sf_code_punctuation">,</span> y<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span> punto<span class="sf_code_punctuation">;</span>

punto p1<span class="sf_code_punctuation">,</span> p2<span class="sf_code_punctuation">,</span> <span class="sf_code_operator">*</span>pp <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>

p1<span class="sf_code_punctuation">.</span>x <span class="sf_code_operator">=</span> <span class="sf_code_number">4.5</span><span class="sf_code_punctuation">;</span>

pp <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>p1<span class="sf_code_punctuation">;</span>

<span class="sf_code_punctuation">(</span><span class="sf_code_operator">*</span>pp<span class="sf_code_punctuation">).</span>x <span class="sf_code_operator">=</span> <span class="sf_code_number">3.2</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Equivale a scrivere p1.x = 3.2;</span>
pp<span class="sf_code_operator">-&gt;</span>x <span class="sf_code_operator">=</span> <span class="sf_code_number">3.2</span><span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Equivale alla scrittura sopra</span>

<span class="sf_code_comment">/*
(p1.x = 3.2;) == ((*pp).x = 3.2;) == (pp-&gt;x = 3.2;)
*/</span>
</code></pre><hr>
<h2 id="Array e puntatori">Array e puntatori</h2>
<h3 id="Gli array nella memoria centrale">Gli array nella memoria centrale</h3>
Un array viene memorizzato come un <i>blocco contiguo</i> a partire da un indirizzo di partenza: l’<b>indirizzo base</b>. Il nome della variabile array (senza le parentesi quadre per la posizione) equivale all’indirizzo di partenza, ossia l’indirizzo del primo elemento dell’array.

Esempio:
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">{</span><span class="sf_code_number">1.0</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">2.1</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">3.2</span><span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">float</span> p <span class="sf_code_operator">=</span> a<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Indirizzo base dell’array a in p</span>
<span class="sf_code_comment">/*
(p = a) == (p = &a[0])
*/</span></code></pre>
<p><br></p>
<h3 id="Usare gli array come puntatori">Usare gli array come puntatori</h3>
<p>È possibile accedere ad un array attraverso i puntatori:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span>“<span class="sf_code_operator">%</span>f”<span class="sf_code_punctuation">,</span> a <span class="sf_code_operator">+</span> i<span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Più in generale, se <code class='code-inline'>a</code> è una variabile di tipo array, l’espressione <code class='code-inline'>a[i]</code> è uguale all’espressione <code class='code-inline'>*(a+i)</code>.</p>
<br>
<p><b>Dimensione ed offset di un array</b>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>a<span class="sf_code_punctuation">[</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">];</span>

<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span>“dimensione a<span class="sf_code_punctuation">:</span> <span class="sf_code_operator">%</span>lu\n”<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span>a<span class="sf_code_punctuation">)</span> <span class="sf_code_operator">/</span> <span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span><span class="sf_code_punctuation">));</span> <span class="sf_code_comment">//Stampa 5</span>
<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span>“posizione p<span class="sf_code_punctuation">:</span> <span class="sf_code_operator">%</span>lu\n”<span class="sf_code_punctuation">,</span> p <span class="sf_code_operator">-</span> a<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Stampa 3</span></code></pre>
<p><br></p>
<p>Abbiamo già visto scrivere <code class='code-inline'>a</code> all’interno di un’istruzione: significa scrivere un indirizzo di memoria: l’indirizzo base dell’array <code class='code-inline'>a</code>. Tuttavia <code class='code-inline'>a</code> e <code class='code-inline'>p</code> <b>non sono la stessa cosa</b>: <code class='code-inline'>a</code> è un valore puntatore <b>costante</b>. Si può assegnare un valore a <code class='code-inline'>p</code> perché è una <b>variabile</b>, ma non posso fare ciò con <code class='code-inline'>a</code>. Posso scrivere <code class='code-inline'>a</code> al posto di <code class='code-inline'>p</code> in tutte le istruzioni che <b>non modificano</b> il valore di <code class='code-inline'>p</code>, ma che lo utilizzano soltanto.</p>
<p>Ecco perché:</p>
<ul><li>Non è possibile usare l’operatore <code class='code-inline'>=</code> per copiare il contenuto di un array o una stringa
</li><li>Non si usa <code class='code-inline'>&</code> per leggere una stringa: il nome della variabile è già il suo indirizzo
</li><li>Non si può usare l’operatore <code class='code-inline'>==</code> per confrontare due array o due stringhe
</li></ul>
<hr>
<h2 id="Funzioni e puntatori">Funzioni e puntatori</h2>
<h3 id="Puntatori come parametri">Puntatori come parametri</h3>
<p>In C, i parametri di una funzione possono essere dei puntatori:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>a<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	a<span class="sf_code_operator">++</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> f <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span>
	p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>f<span class="sf_code_punctuation">;</span>

	<span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span>p<span class="sf_code_punctuation">);</span>

	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Risultato: <code class='code-inline'>p</code> continua a puntare ad <code class='code-inline'>f</code>, mentre <code class='code-inline'>a</code> punta a <code class='code-inline'>f + 1</code>, ma poiché quando la funzione <code class='code-inline'>fun(float *a)</code> termina, la variabile puntatore <code class='code-inline'>*a</code> viene eliminata, le variabili <code class='code-inline'>p</code> ed <code class='code-inline'>f</code> non hanno nessuna modifica.</p>
<br>
<p><b>Attenzione</b>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>a<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_operator">*</span>a <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> f <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">,</span> <span class="sf_code_operator">*</span>p<span class="sf_code_punctuation">;</span>
	p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>f<span class="sf_code_punctuation">;</span>
	
	<span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span>p<span class="sf_code_punctuation">);</span>
	
	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>In questo caso, la dereferenziazione fa sì che la variabile a cui punta <code class='code-inline'>p</code> diventi 0.</p>
<p>Ecco perché si parla, un po’ impropriamente, di passaggio di indirizzo e per valore:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>a<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_operator">*</span>a <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> f <span class="sf_code_operator">=</span> <span class="sf_code_number">3.4</span><span class="sf_code_punctuation">;</span>
	
	<span class="sf_code_function">fun</span><span class="sf_code_punctuation">(</span><span class="sf_code_operator">&</span>f<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Posso solo cambiare il valore di f, non il suo indirizzo</span>
	
	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>In C, ci sono diverse notazioni che si possono usare per dichiarare un parametro di tipo array:</p>
<ul><li><code class='code-inline'>void f(float a[DIM]);</code>
</li><li><code class='code-inline'>void f(float a[]);</code>
</li><li><code class='code-inline'>void f(float *a);</code>
</li></ul>
<p>La differenza è solo estetica: tutte e tre le varianti sono funzionalmente equivalenti.</p>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_comment">/* Si può anche scrivere:
int sum(int vettore[], int n)
int sum(int vettore[5], int n) (il subscript viene ignorato)
Entrambe vengono tradotte nella forma sottostante
*/</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">sum</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> <span class="sf_code_operator">*</span>v<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> somma <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">,</span> i<span class="sf_code_punctuation">;</span>

	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> n<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
		somma <span class="sf_code_operator">+=</span> vettore<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">];</span> <span class="sf_code_comment">//vettore[i] == *(vettore + i)</span>
	
	<span class="sf_code_keyword">return</span> somma<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> a<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">{</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">2</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">,</span> <span class="sf_code_number">4</span><span class="sf_code_punctuation">},</span> somma<span class="sf_code_punctuation">;</span>

	somma <span class="sf_code_operator">=</span> <span class="sf_code_function">sum</span><span class="sf_code_punctuation">(</span>a<span class="sf_code_punctuation">,</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">}</span>
</code></pre><hr>
<h2 id="Gestione dei file in C">Gestione dei file in C</h2>
<h3 id="Memoria di massa e memoria centrale">Memoria di massa e memoria centrale</h3>
La memoria di massa è un dispositivo di memorizzazione generalmente presente in un calcolatore. Si differenzia dalla memoria centrale per dimensioni, costo, persistenza e prestazioni. I <b>file</b> sono lo strumento che consente di memorizzare delle informazioni nella memoria di massa del calcolatore.

<h3 id="File come flussi">File come flussi</h3>
Un flusso (<i>stream</i>) di dati è un meccanismo i cui principali usi sono:
<ul><li>Lo scambio di dati con le periferiche
</li><li><b>Lettura e scrittura</b> dei dati memorizzati sul disco fisso
</li></ul>
<p>In C i file sono quindi rappresentati come flussi e vengono fornite diverse funzionalità nella libreria <code class='code-inline'>stdio.h</code> per la loro gestione:</p>
<ul><li>Il flusso di informazione può essere testuale (flusso di caratteri) o binario (flusso di byte)
</li><li>Consente di avere file ad <i>accesso sequenziale</i> e ad <i>accesso diretto</i> (o <i>casuale</i>)
</li></ul>
<br>
<h3 id="Apertura e chiusura di un file">Apertura e chiusura di un file</h3>
<p>Per poter utilizzare un file in un programma C è prima necessario <i>aprirlo</i>:</p>
<pre><code class='code-multiline' lang='c'>FILE <span class="sf_code_operator">*</span><span class="sf_code_function">fopen</span><span class="sf_code_punctuation">(</span>filename<span class="sf_code_punctuation">,</span> mode<span class="sf_code_punctuation">)</span></code></pre>
<p><br></p>
<ul><li><code class='code-inline'>filename</code> è il nome del file da aprire, incluso il path
</li><li><code class='code-inline'>mode</code> è una stringa che serve a specificare come verrà utilizzato il file
</li><li>La funzione ritorna un puntatore di tipo <code class='code-inline'>FILE</code>, una particolare struttura dati che consente di tenere traccia dell’ultima posizione letta e scritta nel file, del suo stato, ecc. Se l’operazione non ha successo, viene ritornato il valore <code class='code-inline'>NULL</code>.
</li></ul>
<br>
<h4 id="Modalità di apertura di un file">Modalità di apertura di un file</h4>
<ul><li><code class='code-inline'>r</code>: Apre un file testuale in lettura
</li><li><code class='code-inline'>w</code>: Crea un file testuale in scrittura
</li><li><code class='code-inline'>a</code>: Apre o crea un file testuale e si posiziona alla fine del file
</li><li><code class='code-inline'>rb</code>: Apre un file binario in lettura
</li><li><code class='code-inline'>wb</code>: Crea un file binario in lettura
</li><li><code class='code-inline'>ab</code>: Apre o crea un file binario e si posiziona alla fine del file
</li><li><code class='code-inline'>r+</code>: Apre un file testuale in lettura e scrittura
</li><li><code class='code-inline'>w+</code>: Crea un file testuale in lettura e scrittura
</li><li><code class='code-inline'>rb+</code>: Apre un file binario in lettura e scrittura
</li><li><code class='code-inline'>wb+</code>: Crea un file binario in lettura e scrittura
</li></ul>
<p>Una volta utilizzato un file in un programma, è necessario chiuderlo:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">fclose</span><span class="sf_code_punctuation">(</span>FILE <span class="sf_code_operator">*</span>fp<span class="sf_code_punctuation">)</span></code></pre>
<p><br></p>
<p><code class='code-inline'>fp</code> è il puntatore al file da chiudere.</p>
<br>
<p>La funzione ritorna 0 se l’operazione viene eseguita correttamente, altrimenti restituisce un valore speciale <code class='code-inline'>EOF</code> definito in <code class='code-inline'>stdio.h</code>, che viene generalmente utilizzato come carattere terminatore di un file.</p>
<br>
<h3 id="Operazioni di lettura e scrittura">Operazioni di lettura e scrittura</h3>
<p>Le operazioni di lettura e scrittura possono essere effettuate in quattro modi diversi:</p>
<ul><li>Precisando il formato dei dati in ingresso ed in uscita
</li><li>Accedendo ai dati carattere per carattere
</li><li>Linea per linea
</li><li>Blocco per blocco
</li></ul>
<p>Generalmente si adotta l’accesso linea per linea nel caso di flussi di testo e l’accesso carattere per carattere o blocco per blocco in presenza di flussi binari.</p>
<br>
<h4 id="Lettura e scrittura formattata">Lettura e scrittura formattata</h4>
<p>Le funzioni <code class='code-inline'>fprintf</code> e <code class='code-inline'>fscanf</code> consentono operazioni formattate analoghe a quelle di <code class='code-inline'>scanf</code> e <code class='code-inline'>printf</code>. Restituiscono il numero degli elementi effettivamente letti o stampati o restituiscono un numero negativo in caso di errore.</p>
<br>
<p>Sintassi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">fprintf</span><span class="sf_code_punctuation">(</span>fp<span class="sf_code_punctuation">,</span> ctrl_str<span class="sf_code_punctuation">,</span> <span class="sf_code_punctuation">...)</span>
<span class="sf_code_keyword">int</span> <span class="sf_code_function">fscanf</span><span class="sf_code_punctuation">(</span>fp<span class="sf_code_punctuation">,</span> ctrl_str<span class="sf_code_punctuation">,</span> <span class="sf_code_punctuation">...)</span></code></pre>
<p><br></p>
<p><code class='code-inline'>fp</code> è il puntatore al file dal quale leggere o dove scrivere, gli argomenti successivi sono analoghi a quelli usati con <code class='code-inline'>printf</code> e <code class='code-inline'>scanf</code>.</p>
<br>
<h4 id="Lettura e scrittura di un carattere">Lettura e scrittura di un carattere</h4>
<ul><li>Lettura: <code class='code-inline'>int fgetc(FILE *fp)</code>
<ul><li>	Riceve come argomento il file da cui leggere
</li><li>	Restituisce il codice del carattere letto o <code class='code-inline'>EOF</code> in caso di errore
</li></ul></li><li>Scrittura: <code class='code-inline'>int fputc(int c, FILE *fp)</code>
<ul><li>	Riceve come argomenti il codice del carattere da scrivere ed il file su cui scrivere
</li><li>	Restituisce il codice del carattere scritto o <code class='code-inline'>EOF</code> in caso di errore
</li></ul>
</li></ul>
<br>
<h4 id="Lettura e scrittura di stringhe">Lettura e scrittura di stringhe</h4>
<ul><li>Lettura: <code class='code-inline'>char *fgets (char *s, int n, FILE *fp)</code>
<ul><li>	Legge dal file puntato da <code class='code-inline'>fp</code> fino a n - 1 caratteri (si interrompe nel caso raggiunga prima il carattere <code class='code-inline'>\n</code> o la fine del file) e mette i caratteri letti nella stringa s (aggiungendo il carattere terminatore <code class='code-inline'>\0</code>)
</li><li>	La funzione restituisce l’indirizzo di <code class='code-inline'>s</code> se ha successo o <code class='code-inline'>NULL</code> in caso di errore
</li></ul></li><li>Scrittura: <code class='code-inline'>int fputs (char *s, FILE *fp)</code>
<ul><li>	Scrive nel file puntato da <code class='code-inline'>fp</code> il contenuto della stringa <code class='code-inline'>s</code> (fino a raggiungere il carattere terminatore <code class='code-inline'>\0</code>);
</li><li>	restituisce 0 in caso l’operazione abbia avuto successo
</li></ul>
</li></ul>
<br>
<h4 id="Operazione di gestione degli errori">Operazione di gestione degli errori</h4>
<ul><li><code class='code-inline'>int ferror(FILE *fp)</code>
<ul><li>	Controlla se è stato commesso un errore nella precedente operazione di lettura o scrittura
</li><li>	Restituisce 0 se nessun errore è stato commesso, un valore diverso da 0 in caso contrario
</li></ul></li><li><code class='code-inline'>int feof(FILE *fp)</code>
<ul><li>	Controlla se è stata raggiunta la fine del file nella precedente operazione di lettura o scrittura
</li><li>	Restituisce 0 se la condizione di fine file non è stata raggiunga, un valore diverso da 0 in caso contrario
</li></ul>
</li></ul>
<br>
<h4 id="Lettura e scrittura per blocchi">Lettura e scrittura per blocchi</h4>
<ul><li>Lettura: <code class='code-inline'>int fread(ptr, dim, num, FILE *fp)</code>
<ul><li>	Legge al più <code class='code-inline'>num * dim</code> byte di dati binari o testuali dal file cui fa riferimento <code class='code-inline'>fp</code> e li memorizza nel vettore identificato da <code class='code-inline'>ptr</code> (la lettura termina prima se viene raggiunta la fine del file o si verifica un errore)
</li><li>	La funzione ritorna il numero di elementi effettivamente letti
</li></ul></li><li>Scrittura: <code class='code-inline'>int fwrite(ptr, dim, num, FILE *fp)</code> 
<ul><li>	Scrive <code class='code-inline'>num * dim</code> byte di dati binari o testuali sul file cui fa riferimento <code class='code-inline'>fp</code> prelevandoli dal vettore identificato da <code class='code-inline'>ptr</code>
</li><li>	La funzione ritorna il numero di elementi effettivamente scritti
</li></ul>
</li></ul>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">float</span> x<span class="sf_code_punctuation">,</span> y<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span> punto<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">carica</span><span class="sf_code_punctuation">(</span>FILE <span class="sf_code_operator">*</span>fp<span class="sf_code_punctuation">,</span> punto p<span class="sf_code_punctuation">[])</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> n <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span><span class="sf_code_operator">!</span><span class="sf_code_function">feof</span><span class="sf_code_punctuation">(</span>fp<span class="sf_code_punctuation">))</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_function">it</span><span class="sf_code_punctuation">(</span><span class="sf_code_function">fread</span><span class="sf_code_punctuation">(</span><span class="sf_code_operator">&</span>p<span class="sf_code_punctuation">[</span>n<span class="sf_code_punctuation">],</span> <span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span>punto<span class="sf_code_punctuation">),</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">,</span> fp<span class="sf_code_punctuation">)</span> <span class="sf_code_operator">==</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">)</span>
			n<span class="sf_code_operator">++</span><span class="sf_code_punctuation">;</span>
		<span class="sf_code_keyword">else</span>
			<span class="sf_code_keyword">break</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> n<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Accesso diretto">Accesso diretto</h3>
<h4 id="Spostare l’indicatore di posizione corrente di un file">Spostare l’indicatore di posizione corrente di un file</h4>
<p><code class='code-inline'>int fseek(FILE *fp, long offset, int refpoint)</code></p>
<p>Lo spostamento <code class='code-inline'>offset</code> (in byte) può essere positivo o negativo e si riferisce a <code class='code-inline'>refpoint</code>.</p>
<p><code class='code-inline'>refpoint</code> può assumere tre diversi valori:</p>
<ol start="1"><li><code class='code-inline'>SEEK_SET</code>: indica l’<b>inizio</b> del file
</li><li><code class='code-inline'>SEEK_CUR</code>: indica la <b>posizione corrente</b>
</li><li><code class='code-inline'>SEEK_END</code>: indica la <b>fine</b> del file
</li></ol>
<p>La funzione <code class='code-inline'>fseek</code> restituisce zero se l’operazione ha avuto successo</p>
<br>
<h4 id="Riavvolgere un file">Riavvolgere un file</h4>
<p><code class='code-inline'>rewind(FILE *fp)</code></p>
<p>Questa funzione equivale a <code class='code-inline'>fseek(*fp, 0, SEEK_SET)</code>. È un’operazione talmente comune che è stata creata una funzione apposita per efficienza.</p>
<br>
<h4 id="Capire dove si trova al momento l’indicatore di posizione">Capire dove si trova al momento l’indicatore di posizione</h4>
<p><code class='code-inline'>long ftell(FILE *fp)</code></p>
<p>Restituisce il valore corrente dell’indicatore di posizione, pari al numero di byte dall’inizio del file per un file binario, ad un valore dipendente dal sistema per i file testuali.</p>
<hr>
<h2 id="File e sistema operativo">File e sistema operativo</h2>
<h3 id="File e programmi in C">File e programmi in C</h3>
<p>Per utilizzare un file in C è necessario prima aprire un flusso di comunicazione per associare il programma al file. Il sistema operativo tiene traccia di tutti i file aperti da ogni programma nella <b>tabella dei file aperti</b>.</p>
<br>
<p>Per ogni file aperto, si tiene traccia di:</p>
<ul><li>Modalità di utilizzo del file
</li><li>Posizione corrente sul file
</li><li>Indicatore di errore
</li><li>Indicatore <i>end of file</i>
</li></ul>
<br>
<p>Una volta finito di utilizzare un file in un programma, è possibile chiuderlo.</p>
<p>Per ogni programma, il sistema operativo tiene aggiornata una tabella dei file aperti. I puntatori <code class='code-inline'>FILE</code> restituiti dalla <code class='code-inline'>fopen</code> sono riferimenti alla tabella dei file aperti.</p>
<br>
<p><b>Tre flussi standard vengono automaticamente aperti</b> quando inizia l’esecuzione di un programma:</p>
<ul><li><code class='code-inline'>stdin</code>: input del terminale (tastiera)
</li><li><code class='code-inline'>stdout</code>: output del terminale
</li><li><code class='code-inline'>stderr</code>: errori del terminale
</li></ul>
<p>Le istruzioni <code class='code-inline'>printf</code> e <code class='code-inline'>scanf</code> utilizzano questi flussi standard.</p>
<p>La funzione <code class='code-inline'>printf</code> è quindi equivalente alla funzione <code class='code-inline'>fprintf(stdout, ...);</code>. Similmente, <code class='code-inline'>scanf</code> equivale a <code class='code-inline'>fscanf(stdin, ...)</code>.</p>
<br>
<h3 id="Struttura della tabella dei file aperti">Struttura della tabella dei file aperti</h3>
<p><img src='Introduzione%20al%20C/Immagine%202020-11-04%20140430.png'></p>
<hr>
<h2 id="Parametri a riga di comando">Parametri a riga di comando</h2>
<p>Il compilatore <code class='code-inline'>gcc</code> si lancia con il comando <code class='code-inline'>gcc source.c -o executablename</code>.</p>
<p>Dato che <code class='code-inline'>gcc</code> è il nome dell’eseguibile, possiamo dedurre che <code class='code-inline'>source.c -o executablename</code> sono <b>argomenti</b> che vengono forniti in input al programma <code class='code-inline'>gcc</code>.</p>
<p>In C, per creare un eseguibile a cui sia possibile passare argomenti, è necessario modificare il prototipo del <code class='code-inline'>main</code>:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> argc<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">char</span> <span class="sf_code_operator">*</span>argv<span class="sf_code_punctuation">[])</span>
</code></pre><ul><li><code class='code-inline'>argc</code> contiene il numero di argomenti con cui il programma viene lanciato, incluso il nome del programma
</li><li><code class='code-inline'>*argv[]</code> è un array di stringhe che contiene tutti gli argomenti con cui il programma viene lanciato (<code class='code-inline'>argv[0]</code> è il nome completo dell’eseguibile lanciato con eventuale percorso)
</li></ul>
<br>
<h3 id="Utilizzare gli argomenti in C">Utilizzare gli argomenti in C</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> argc<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">char</span> <span class="sf_code_operator">*</span>argv<span class="sf_code_punctuation">[])</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> i<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> argc<span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span><span class="sf_code_string">"arg%d: %s\n"</span><span class="sf_code_punctuation">,</span> i<span class="sf_code_punctuation">,</span> argv<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]);</span>

	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>
</code></pre><h2 id="Matrici e puntatori">Matrici e puntatori</h2>
Le matrici vengono memorizzate come un <i>blocco contiguo</i> a partire da un indirizzo base, riga dopo riga. Il nome della variabile matrice è l’indirizzo base della matrice.
In questo caso, la posizione successiva <code class='code-inline'>M + 1</code> <b>non indica</b> il secondo elemento della matrice, ma la <b>seconda riga</b>. Perciò lo spostamento dell’indirizzo dipende dal <b>numero di colonne</b> della matrice.

Esempio:
<code class='code-inline'>float M[5][4];</code>
<ul><li>M <b>non è</b> un puntatore <code class='code-inline'>float *</code>
<ul><li>	<code class='code-inline'>float *p = M; //Errore</code>
</li></ul></li><li>M è un <b>puntatore ad un array</b> di 4 float: <code class='code-inline'>float (*)[4]</code> (4 è la dimensione di colonna della matrice
<ul><li>	<code class='code-inline'>float *p[4] = M; //Punta alla prima riga di M</code>
</li></ul></li><li>È comunque possibile puntare ad un singolo elemento di M
<ul><li>	<code class='code-inline'>float *p = &M[i][j]; //Punta all’elemento M[i][j]</code>
</li></ul></li><li>Le operazioni di aritmetica sui puntatori hanno un effetto diverso a seconda di come è dichiarato il puntatore:
</li></ul>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p1 <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>M<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_punctuation">(</span><span class="sf_code_operator">*</span>p2<span class="sf_code_punctuation">)[</span><span class="sf_code_number">4</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">=</span> M<span class="sf_code_punctuation">;</span>
</code></pre><ul><li>		<code class='code-inline'>p1 + i</code> è l’indirizzo dell’i-esimo elemento di M (letta per righe)
</li><li>	<code class='code-inline'>p2 + i</code> denota l’indirizzo di partenza dell’i-esima riga di M
</li><li>	<code class='code-inline'>p1 + i</code> equivale a <code class='code-inline'>&M[0][0] + i</code>
</li><li>	<code class='code-inline'>p2 + i</code> equivale a <code class='code-inline'>M + i</code>
</li></ul>
<br>
<p>È possibile accedere ad una attrice attraverso gli indirizzi:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">float</span> M<span class="sf_code_punctuation">[</span><span class="sf_code_number">5</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">3</span><span class="sf_code_punctuation">];</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">5</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>j <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">,</span> j <span class="sf_code_operator">&lt;</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">;</span> j<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span>“<span class="sf_code_operator">%</span>f”<span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>M<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">+</span> i <span class="sf_code_operator">*</span> <span class="sf_code_number">3</span> <span class="sf_code_operator">+</span> j<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<p>Più in generale, se M è una matrice di r righe e c colonne:</p>
<p><code class='code-inline'>M[i][j]</code> = <code class='code-inline'>*(&M[0][0] + i * c + j</code></p>
<br>
<p>Calcolare indice di riga e colonna di una matrice:</p>
<pre><code class='code-multiline' lang='c'>floatM<span class="sf_code_punctuation">[</span>r<span class="sf_code_punctuation">][</span>c<span class="sf_code_punctuation">];</span> <span class="sf_code_comment">//r e c costanti</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>p <span class="sf_code_operator">=</span> <span class="sf_code_operator">&</span>M<span class="sf_code_punctuation">[</span>rr<span class="sf_code_punctuation">][</span>cc<span class="sf_code_punctuation">];</span> <span class="sf_code_comment">//Puntatore ad un elemento</span>

<span class="sf_code_keyword">int</span> i <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>p <span class="sf_code_operator">-</span> <span class="sf_code_operator">&</span>M<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">])</span> <span class="sf_code_operator">/</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Calcola l’indice di riga</span>
<span class="sf_code_keyword">int</span> j <span class="sf_code_operator">=</span> <span class="sf_code_punctuation">(</span>p <span class="sf_code_operator">-</span> <span class="sf_code_operator">&</span>M<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">][</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">])</span> <span class="sf_code_operator">%</span> c<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//Calcola l’indice di colonna</span></code></pre>
<p><br></p>
<h2 id="Matrici e funzioni">Matrici e funzioni</h2>
<p>Come per gli array, ci sono tre notazioni equivalenti per dichiarare un parametro formale di tipo matrice:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[</span>R<span class="sf_code_punctuation">][</span>C<span class="sf_code_punctuation">]);</span>
<span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> a<span class="sf_code_punctuation">[][</span>C<span class="sf_code_punctuation">]);</span>
<span class="sf_code_keyword">void</span> <span class="sf_code_function">f</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span> <span class="sf_code_punctuation">(</span><span class="sf_code_operator">*</span>a<span class="sf_code_punctuation">)[</span>C<span class="sf_code_punctuation">]);</span>
</code></pre>È sempre necessario specificare il <b>numero di colonne</b>, senza il quale l’aritmetica degli indirizzi non potrebbe essere applicata correttamente.

<h2 id="Array di puntatori e puntatori ad array">Array di puntatori e puntatori ad array</h2>
Un puntatore ad un array è sostanzialmente una matrice
<code class='code-inline'>float (*p)[3];</code>
Un array di puntatori è più flessibile e permette di creare una matrice con righe di dimensioni diverse
<code class='code-inline'>float *p[3];</code>

<h2 id="Allocazione dinamica della memoria">Allocazione dinamica della memoria</h2>
In C dobbiamo dichiarare una variabile ogni volta che abbiamo bisogno di riservare uno spazio nella memoria di un calcolatore per ospitare dati. Tuttavia, a volta sarebbe comodo avere uno strumento <i>flessibile</i> della dichiarazione di una variabile per <i>creare</i> questo spazio della memoria:

<h3 id="Allocare la memoria">Allocare la memoria</h3>
In C è possibile <i>allocare</i> uno spazio di memoria tramite la funzione <code class='code-inline'>malloc</code> contenuta nella libreria <code class='code-inline'>stdlib</code>:
<code class='code-inline'>type *p = malloc (size);</code>
<ul><li><code class='code-inline'>size</code> è la quantità in byte di memoria da allocare ed è generalmente espressa come <code class='code-inline'>n * sizeof(type)</code>
</li><li>La funzione riserva uno spazio di memoria delle dimensioni richieste e ne restituisce l’indirizzo
</li><li>Nel caso non sia possibile riservare uno spazio di memoria con le caratteristiche richieste, la funzione ritorna <code class='code-inline'>NULL</code>
</li></ul>
<br>
<p>Esempio:</p>
<p><code class='code-inline'>float *v = malloc(5 * sizeof(float)); //Alloca 5 float</code></p>
<br>
<p><code class='code-inline'>malloc</code> e funzioni:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_operator">*</span><span class="sf_code_function">array_vuoto</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> <span class="sf_code_operator">*</span>a <span class="sf_code_operator">=</span> </code></pre>
<p><br></p>
<h3 id="Allocare ed inizializzare la memoria">Allocare ed inizializzare la memoria</h3>
<p>Un’altra funzione din C che consente di alloccare la memoria è la <code class='code-inline'>calloc</code> contenuta nella libreria <code class='code-inline'>stdlib</code>:</p>
<p><code class='code-inline'>type *p = calloc(n, size);</code></p>
<ul><li><code class='code-inline'>n</code> è il numero di elementi da allocare
</li><li><code class='code-inline'>size</code> è la quantità in byte di ciascun elemento da allocare, in genere espressa come <code class='code-inline'>sizeof(type)</code>
</li><li>La funzione riserva uno spazio di memoria delle dimensioni richieste, inizializza tutti i bit della memoria allocata a 0 e ne restituisce l’indirizzo
</li><li>Nel caso non sia possibile riservare uno spazio di memoria con le caratteristiche richieste, la funzione ritorna <code class='code-inline'>NULL</code>
</li></ul>
<br>
<p>Esempi:</p>
<p><code class='code-inline'>float *v = calloc(5, sizeof(float)); //Alloca 5 float</code></p>
<br>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> <span class="sf_code_operator">*</span><span class="sf_code_function">array_vuoto2</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span> n<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">return</span> <span class="sf_code_function">calloc</span><span class="sf_code_punctuation">(</span>n<span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">int</span><span class="sf_code_punctuation">));</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_punctuation">...</span>
	<span class="sf_code_keyword">int</span> <span class="sf_code_operator">*</span>v <span class="sf_code_operator">=</span> <span class="sf_code_function">array_vuoto</span><span class="sf_code_punctuation">(</span><span class="sf_code_number">10</span><span class="sf_code_punctuation">);</span>
	<span class="sf_code_punctuation">...</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<h3 id="Deallocare la memoria">Deallocare la memoria</h3>
<p>In C è possibile <i>deallocare</i> uno spazio di memoria con la funzione <code class='code-inline'>free</code> contenuta nella libreria <code class='code-inline'>stdlib</code>:</p>
<p><code class='code-inline'>free(address)</code></p>
<p>La funzione riceve come parametro in ingresso l’indirizzo di uno spazio di memoria <b>precedentemente allocato</b> e <b>lo libera</b>.</p>
<br>
<p>Esempio:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_punctuation">...</span>
<span class="sf_code_keyword">float</span> <span class="sf_code_operator">*</span>v <span class="sf_code_operator">=</span> <span class="sf_code_function">calloc</span><span class="sf_code_punctuation">(</span><span class="sf_code_number">500</span><span class="sf_code_punctuation">,</span> <span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">float</span><span class="sf_code_punctuation">));</span>
<span class="sf_code_punctuation">...</span>
<span class="sf_code_function">free</span><span class="sf_code_punctuation">(</span>v<span class="sf_code_punctuation">);</span></code></pre>
<p><br></p>
<h3 id="Lavorare con una sequenza di elementi">Lavorare con una sequenza di elementi</h3>
<p>Leggiamo una sequenza di interi terminata da uno zero:</p>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">int</span> v<span class="sf_code_punctuation">[</span>N<span class="sf_code_punctuation">],</span> i<span class="sf_code_punctuation">;</span>
<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span>“<span class="sf_code_operator">%</span>d”<span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>v<span class="sf_code_punctuation">[</span><span class="sf_code_number">0</span><span class="sf_code_punctuation">]);</span>
<span class="sf_code_keyword">for</span><span class="sf_code_punctuation">(</span>i <span class="sf_code_operator">=</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span> i <span class="sf_code_operator">&lt;</span> N <span class="sf_code_operator">&&</span> v<span class="sf_code_punctuation">[</span>i <span class="sf_code_operator">-</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">]</span> <span class="sf_code_operator">!=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span> i<span class="sf_code_operator">++</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_function">scanf</span><span class="sf_code_punctuation">(</span>“<span class="sf_code_operator">%</span>d”<span class="sf_code_punctuation">,</span> <span class="sf_code_operator">&</span>v<span class="sf_code_punctuation">[</span>i<span class="sf_code_punctuation">]);</span>
</code></pre><b>Come scelgo N?</b>
<ul><li>N troppo grande: spreco memoria
</li><li>N troppo piccolo: non riesco a memorizzare un’intera sequenza
</li></ul>
<p>Soluzione: <b>Lista</b></p>
<br>
<h2 id="Liste">Liste</h2>
<p>Una lista è una struttura dati che consente di rappresentare una sequenza di elementi:</p>
<ul><li>di lunghezza variabile (non definita a priori)
</li><li>che permette di inserire e rimuovere elementi <i>dinamicamente</i>
</li></ul>
<p>La lista viene implementata attraverso una sequenza di <i>nodi</i>, ciascuno dei quali contiene:</p>
<ul><li>un elemento della sequenza che so vuole rappresentare
</li><li>un puntatore al nodo successivo
</li></ul>
<p>L’accesso alla lista avviene tramite un puntatore <code class='code-inline'>head</code> che punta al primo nodo della lista.</p>
<p>Il puntatore dell’ultimo nodo conterrà il valore <code class='code-inline'>NULL</code> per indicare che non ci sono elementi successivi (nel caso la lista sia vuota, sarà <code class='code-inline'>head</code> a contenere <code class='code-inline'>NULL</code>)</p>
<br>
<h3 id="Sintassi della lista">Sintassi della lista</h3>
<pre><code class='code-multiline' lang='c'><span class="sf_code_keyword">struct</span> nodo
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> el<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>next<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">};</span>

<span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>head <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>

<span class="sf_code_comment">//oppure</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>lista<span class="sf_code_punctuation">;</span>
lista head<span class="sf_code_punctuation">;</span></code></pre>
<p><br></p>
<h3 id="Operazioni sulle liste">Operazioni sulle liste</h3>
<ol start="1"><li>Calcolare la lunghezza di una lista
</li><li>Ricerca di un elemento
</li><li>Inserimento di un elemento in testa, in coda
</li><li>Rimuovi un elemento in testa o in coda
</li><li>Rimuovi un elemento specifico
</li></ol>
<br>
<pre><code class='code-multiline' lang='c'><span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdio.h&gt;</span>
<span class="sf_code_macro">#include </span><span class="sf_code_string">&lt;stdlib.h&gt;</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">int</span> data<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">struct</span> nodo
<span class="sf_code_punctuation">{</span>
	data el<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>next<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">};</span>

<span class="sf_code_keyword">typedef</span> <span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>lista<span class="sf_code_punctuation">;</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">lunghezza</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Lunghezza della lista</span>
<span class="sf_code_keyword">int</span> <span class="sf_code_function">lunghezza_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Lunghezza della lista</span>
<span class="sf_code_keyword">int</span> <span class="sf_code_function">ricerca</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Ricerca di un elemento</span>
<span class="sf_code_keyword">int</span> <span class="sf_code_function">ricerca_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Ricerca di un elemento</span>
lista <span class="sf_code_function">inserisci_testa</span><span class="sf_code_punctuation">(</span>lista ll<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Aggiungi elemento in testa</span>
lista <span class="sf_code_function">inserisci_coda</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Aggiungi elemento in coda</span>
lista <span class="sf_code_function">inserisci_coda_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Aggiungi elemento in coda</span>
lista <span class="sf_code_function">rimuovi_testa</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Rimuovi elemento in testa</span>
lista <span class="sf_code_function">rimuovi_coda</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Rimuovi elemento in coda</span>
lista <span class="sf_code_function">rimuovi</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">);</span> <span class="sf_code_comment">//Rimuovi elemento qualunque</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">main</span><span class="sf_code_punctuation">()</span>
<span class="sf_code_punctuation">{</span>
	lista l <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">int</span> lung<span class="sf_code_punctuation">;</span>
	<span class="sf_code_comment">//Ipotizzo di aver riempito la lista</span>
	lung <span class="sf_code_operator">=</span> <span class="sf_code_function">lunghezza</span><span class="sf_code_punctuation">(</span>l<span class="sf_code_punctuation">)</span>

	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span><span class="sf_code_function">ricerca</span><span class="sf_code_punctuation">(</span>l<span class="sf_code_punctuation">,</span> <span class="sf_code_number">3</span><span class="sf_code_punctuation">))</span>
		<span class="sf_code_function">printf</span><span class="sf_code_punctuation">(</span>“\nL’elemento <span class="sf_code_number">3</span> è presente nella lista\n”<span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">lunghezza</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">int</span> lung <span class="sf_code_operator">=</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	
	<span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		lung<span class="sf_code_operator">++</span><span class="sf_code_punctuation">;</span>
		l <span class="sf_code_operator">=</span> l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">;</span> <span class="sf_code_comment">//(*l).next</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> lung<span class="sf_code_punctuation">;</span>	
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">lunghezza_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">==</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">else</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span> <span class="sf_code_operator">+</span> <span class="sf_code_function">lunghezza_ric</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">ricerca</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> el <span class="sf_code_operator">==</span> el<span class="sf_code_punctuation">)</span>
			<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span>
		l <span class="sf_code_operator">=</span> l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

<span class="sf_code_keyword">int</span> <span class="sf_code_function">ricerca_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">==</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">0</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> el <span class="sf_code_operator">==</span> el<span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_number">1</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">return</span> <span class="sf_code_function">ricerca_ric</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">,</span> el<span class="sf_code_punctuation">);</span>
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">inserisci_testa</span><span class="sf_code_punctuation">(</span>lista ll<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>tmp <span class="sf_code_operator">=</span> <span class="sf_code_function">malloc</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">struct</span> nodo<span class="sf_code_punctuation">));</span>
	tmp <span class="sf_code_operator">-&gt;</span> el <span class="sf_code_operator">=</span> el<span class="sf_code_punctuation">;</span>
	tmp <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> ll<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">return</span> tmp
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">inserisci_coda</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">struct</span> nodo <span class="sf_code_operator">*</span>temp <span class="sf_code_operator">=</span> <span class="sf_code_function">malloc</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">sizeof</span><span class="sf_code_punctuation">(</span><span class="sf_code_keyword">struct</span> nodo<span class="sf_code_punctuation">));</span>
	lista cur <span class="sf_code_operator">=</span> l<span class="sf_code_punctuation">;</span>
	tmp <span class="sf_code_operator">-&gt;</span> el <span class="sf_code_operator">=</span> el<span class="sf_code_punctuation">;</span>
	tmp <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span>cur <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		cur <span class="sf_code_operator">=</span> cur <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
	cur <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> tmp<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">return</span> l<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">inserisci_coda_ric</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">==</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_function">inserisci_testa</span><span class="sf_code_punctuation">(</span>l<span class="sf_code_punctuation">,</span> el<span class="sf_code_punctuation">);</span>
	<span class="sf_code_keyword">else</span>
	<span class="sf_code_punctuation">{</span>
		l <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> <span class="sf_code_function">inserisci_coda</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">,</span> el<span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">return</span> l<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">rimuovi_testa</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	lista tmp<span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		tmp <span class="sf_code_operator">=</span> l<span class="sf_code_punctuation">;</span>
		l <span class="sf_code_operator">=</span> l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">;</span>
		<span class="sf_code_function">free</span><span class="sf_code_punctuation">(</span>tmp<span class="sf_code_punctuation">);</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">return</span> l<span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">rimuovi_coda</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	lista cur <span class="sf_code_operator">=</span> l<span class="sf_code_punctuation">,</span> prec <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
	<span class="sf_code_punctuation">{</span>
		<span class="sf_code_keyword">while</span><span class="sf_code_punctuation">(</span>cur <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_punctuation">{</span>
			prec <span class="sf_code_operator">=</span> cur<span class="sf_code_punctuation">;</span>
			cur <span class="sf_code_operator">=</span> cur <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">;</span>
		<span class="sf_code_punctuation">}</span>
		<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>prec <span class="sf_code_operator">!=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_punctuation">{</span>
			prec <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
			<span class="sf_code_function">free</span><span class="sf_code_punctuation">(</span>cur<span class="sf_code_punctuation">);</span>
			<span class="sf_code_keyword">return</span> l<span class="sf_code_punctuation">;</span>
		<span class="sf_code_punctuation">}</span>
		<span class="sf_code_keyword">else</span>
		<span class="sf_code_punctuation">{</span>
			<span class="sf_code_function">free</span><span class="sf_code_punctuation">(</span>cur<span class="sf_code_punctuation">);</span>
			<span class="sf_code_keyword">return</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
		<span class="sf_code_punctuation">}</span>
	<span class="sf_code_punctuation">}</span>
	<span class="sf_code_keyword">else</span>		
		<span class="sf_code_keyword">return</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
<span class="sf_code_punctuation">}</span>

lista <span class="sf_code_function">rimuovi</span><span class="sf_code_punctuation">(</span>lista l<span class="sf_code_punctuation">,</span> data el<span class="sf_code_punctuation">)</span>
<span class="sf_code_punctuation">{</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">==</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_constant">NULL</span><span class="sf_code_punctuation">;</span>
	<span class="sf_code_keyword">if</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> el <span class="sf_code_operator">==</span> el<span class="sf_code_punctuation">)</span>
		<span class="sf_code_keyword">return</span> <span class="sf_code_function">rimuovi_testa</span><span class="sf_code_punctuation">(</span>l<span class="sf_code_punctuation">)</span>
	<span class="sf_code_keyword">else</span>
	<span class="sf_code_punctuation">{</span>
		l <span class="sf_code_operator">-&gt;</span> next <span class="sf_code_operator">=</span> <span class="sf_code_function">rimuovi</span><span class="sf_code_punctuation">(</span>l <span class="sf_code_operator">-&gt;</span> next<span class="sf_code_punctuation">);</span>
		<span class="sf_code_keyword">return</span> l<span class="sf_code_punctuation">;</span>
	<span class="sf_code_punctuation">}</span>
<span class="sf_code_punctuation">}</span></code></pre>
<p><br></p>
<p>Riassumendo:</p>
<ul><li>Strutture dati dinamiche realizzate mediante puntatori
</li><li>Liste: primo e fondamentale (ma non unico) esempio di struttura dinamica
</li><li>Una prima valutazione dell’efficienza della struttura dinamica lista rispetto all’array:
</li></ul>
<ol start="1"><li>Si evita lo spreco di memoria ed il rischio di overflow
</li><li>A prezzo di un lieve aumento di occupazione di memoria dovuto ai puntatori
</li><li>Da un punto di vista del tempo necessario all’esecuzione degli algoritmi: pro e contro (inserire in testa meglio, inserire in coda peggio...)
</li></ol>
<br>
<h2 id="Programmazione modulare">Programmazione modulare</h2>
<p>Un sistema software è costituito da un insieme di moduli e da relazioni tra questi. Ogni modulo è costituito da un’<b>interfaccia</b> e da un’<b>implementazione</b>:</p>
<ul><li>L’interfaccia è l’insieme di tutti e soli i suoi elementi che devono essere conosciuti da chi usa il modulo per farne un uso appropriato
</li><li>L’implementazione è l’insieme dei meccanismi che permettono di <b>realizzare</b> le funzionalità del modulo
</li></ul>
<br>
<h3 id="Linee guida">Linee guida</h3>
<ul><li>Information hiding
<ul><li>	Meno informazioni sono note all’utilizzatore di un modulo, meno vincoli sussistono per l’implementazione
</li><li>	Tuttavia l’interfaccia deve contenere tutte le informazioni necessarie per utilizzare il modulo, per evitare che l’utente sia costretto ad esaminare l’implementazione
</li></ul></li><li>Alta coesione
<ul><li>	È bene che variabili, procedure ed altri elementi spesso utilizzati congiuntamente siano raggruppati nello stesso modulo dando ad ogni modulo un alto livello di coesione interna
</li></ul></li><li>Basso accoppiamento
<ul><li>	Elementi che raramente interagiscono tra loro possono essere 
</li></ul>
</li></ul>
<br>
<h3 id="Modularizzazione in C">Modularizzazione in C</h3>
<p>In C, si utilizzano gli <i>header file</i> <code class='code-inline'>.h</code> per definire le interfacce, principalmente per:</p>
<ul><li>dichiarazione di tipo e variabili
</li><li>dichiarazione di funzione
</li></ul>
<p>Le implementazioni vengono invece incluse in corrispondenti</p>
<br>
<h2 id="Sistemi operativi">Sistemi operativi</h2>
<p>Il sistema operativo è un software importante poiché ha lo scopo di nascondere agli utenti ed ai programmatori tutto ciò che ha a che fare con la gestione dell’hardware presente nel calcolatore.</p>
<br>
<h3 id="Architettura del sistema operativo">Architettura del sistema operativo</h3>
<p>Il sistema operativo è tipicamente organizzato a <i>strati</i>:</p>
<ol start="1"><li>Programmi utente
</li><li>Interprete comandi
</li><li>File system
</li><li>Gestione delle periferiche
</li><li>Gestione della memoria
</li><li>Gestione dei processi
</li><li>Macchina fisica
</li></ol>
<p>Gestione dei processi, della memoria e delle periferiche sono <i>indispensabili</i> per il funzionamento del sistema operativo: ne costituiscono il <b>kernel</b> (<i>nucleo</i>).</p>
<br>
<h3 id="Tipi di sistema operativo">Tipi di sistema operativo</h3>
<p>Esistono diversi tipi di sistema operativo, ma in generale si possono dividere in:</p>
<ul><li><b>Monoutente e monoprogrammato</b>
<ul><li>	Esecuzione di un solo programma alla volta
</li><li>	Utilizzato da un solo utente per volta
</li><li>	Esempio: DOS, prime versioni di iOS (iPhoneOS)
</li></ul></li><li><b>Monoutente e multiprogrammato</b>
<ul><li>	Esecuzione di più programmi alla volta (<i>multitasking</i>)
</li><li>	Utilizzato da un solo utente per volta
</li><li>	Esempio: Windows 95
</li></ul></li><li><b>Multiutente e multiprogrammato</b>
<ul><li>	Multitasking
</li><li>	Più utenti per volta
</li><li>	Esempi: Linux, UNIX, sistemi operativi moderni
</li></ul>
</li></ul>
<p>Non possono esistere sistemi operativi multiutente e monoprogrammati poiché essere multiutente significa poter gestire istanze multiple di uno stesso programma.</p>
<br>
<h3 id="Gestione dei processi nel sistema operativo">Gestione dei processi nel sistema operativo</h3>
<p>Un processo non è esattamente un programma: un programma è del codice che è stato compilato o interpretato che svolge una certa funzione. Nel momento dell’esecuzione del programma, l’istanza del programma in esecuzione in quel momento è detta <b>processo</b> e si distingue poiché si può avere in esecuzione sulla propria macchina più processi dello stesso programma, che lavorano con dati diversi, si trovano in stati diversi.</p>
<p>Il sistema operativo deve essere in grado di gestire l’esecuzione dei processi dei programmi utente. Deve poter distribuire le risorse del sistema ai vari processi equamente ed evitare conflitti e perciò ad ogni programma viene affidata una <b>macchina virtuale</b> realizzata dal sistema operativo che ne consente l’esecuzione come se la CPU del calcolatore fosse interamente dedicata a quel processo.</p>
<p>Il modo in cui le risorse vengono gestite dal sistema operativo cambia a seconda della risorsa:</p>
<ul><li>Alcune sono <b>indivisibili</b>, come i dispositivi di I/O, di rete, CPU
</li><li>Alcune sono <b>divisibili</b>, come la RAM o l’Hard Disk
</li></ul>
<br>
<h3 id="Stato di un processo">Stato di un processo</h3>
<p>Lo stato del processo può essere distinto fra stato <b>interno</b> ed <b>esterno</b>.</p>
<p>Lo stato interno indica:</p>
<ul><li>La prossima istruzione del programma che deve essere eseguita
</li><li>I valori delle variabili e dei registri utilizzati dal processo
</li></ul>
<p>Lo stato esterno indica:</p>
<ul><li>Se il processo è in attesa di un evento (lettura dal disco, inserimento di dati da tastiera…)
</li><li>Se il processo è in esecuzione
</li><li>Se il processo è pronto all’esecuzione e quindi attende di accedere alla CPU
</li></ul>
<br>
<p>I processi appena creati sono messi in stato di <i>pronto</i>, il kernel decide quale processo pronto mettere in esecuzione. Il kernel assegna il processore ad un processo per un quanto di tempo.</p>
<ul><li>Coda dei processi pronti
</li><li>Round-robin
</li><li>Priorità dei processi
</li></ul>
<br>
<p><i>Pre-emption</i>: quando il quanto di tempo è scaduto, il kernel interrompe il processo in esecuzione.</p>
<br>
<h3 id="Processi e sistema operativo">Processi e sistema operativo</h3>
<p>Anche il sistema operativo è implementato tramite processi. Il sistema operativo garantisce che i conflitti tra i processi sono controllati e gestiti correttamente, e perciò viene eseguito in modalità privilegiata (<i>kernel mode</i> o <i>supervisor</i>), così da poter controllare gli altri processi eseguiti in modalità user.</p>
<br>
<h3 id="Chiamate al supervisor">Chiamate al supervisor</h3>
<p>I processi utente per eseguire operazioni privilegiate invocano il supervisor tramite chiamate di sistema.</p>
<p>Perché usare la modalità privilegiata?</p>
<ul><li>Le operazioni di I/O sono operazioni riservate
<ul><li>	Un processo non deve poter andare a scrivere messaggi su un terminale non associato allo stesso processo
</li></ul></li><li>Un processo non deve poter sconfinare al di fuori di uno spazio di memoria
</li><li>La condivisione di risorse dev’essere tale da cautelare i dati di ogni utente
</li></ul>
<br>
<h3 id="Gestione del quanto di tempo">Gestione del quanto di tempo</h3>
<p>Il quanto di tempo è gestito da una particolare interruzione, generata dall’orologio di sistema a una frequenza definita.</p>
<br>
<h3 id="Gestione della memoria nel sistema operativo">Gestione della memoria nel sistema operativo</h3>
<p>La gestione concorrente di molti programmi applicativi comporta la presenza di molti programmi nella RAM. Il sistema operativo offre ad ogni programma la visione di una memoria virtuale, che può avere dimensioni maggiori di quella fisica. Per gestire la memoria virtuale, il sistema operativo dispone di diversi meccanismi:</p>
<ul><li>Rilocazione
</li><li>
</li><li>Segmentazione
</li></ul>
<br>
<h4 id="Rilocazione">Rilocazione</h4>
<p> Il programma non ha accesso alla memoria fisica ma solo alla memoria virtuale, che appare al programma della dimensione totale della memoria installata nel sistema (o anche maggiore). Il programma può riempire la memoria virtuale a partire dall’indirizzo 0. Attraverso la <i>rilocazione</i>, dopo aver calcolato con la compilazione quanta memoria sarà usata, il kernel trova una sezione di memoria fisica libera di quella quantità e segna l’indirizzo iniziale di questa porzione nel <i>registro base</i>. Ogni volta che il programma prova ad accedere all’indirizzo 0, il kernel lo <i>reindirizzerà</i> al vero indirizzo attraverso la somma di un offset.</p>
<p>Questo approccio causa un problema di frammentazione, risolvibile con la paginazione, ossia la divisione della memoria in parti più piccole.</p>
        </div>
        <script type="text/javascript">
            (function() {

    var doc_ols = document.getElementsByTagName("ol");

    for ( i=0; i<doc_ols.length; i++) {

        var ol_start = doc_ols[i].getAttribute("start") - 1;
        doc_ols[i].setAttribute("style", "counter-reset:ol_counter " + ol_start + ";");

    }

})();

        </script>
        <style>
            html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline}html{line-height:1}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}caption,th,td{text-align:left;font-weight:normal;vertical-align:middle}q,blockquote{quotes:none}q:before,q:after,blockquote:before,blockquote:after{content:"";content:none}a img{border:none}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:87.5%;line-height:1.57143em}html{font-size:14px;line-height:1.6em;-webkit-text-size-adjust:100%}body{background:#fcfcfc;color:#545454;text-rendering:optimizeLegibility;font-family:"AvenirNext-Regular"}a{color:#de4c4f;text-decoration:none}h1{font-family:"AvenirNext-Medium";color:#333;font-size:1.6em;line-height:1.3em;margin-bottom:.78571em}h2{font-family:"AvenirNext-Medium";color:#333;font-size:1.3em;line-height:1em;margin-bottom:.62857em}h3{font-family:"AvenirNext-Medium";color:#333;font-size:1.15em;line-height:1em;margin-bottom:.47143em}p{margin-bottom:1.57143em;hyphens:auto}hr{height:1px;border:0;background-color:#dedede;margin:-1px auto 1.57143em auto}ul,ol{margin-bottom:.31429em}ul ul,ul ol,ol ul,ol ol{margin-bottom:0px}ol{counter-reset:ol_counter}ol li:before{content:counter(ol_counter) ".";counter-increment:ol_counter;color:#e06e73;text-align:right;display:inline-block;min-width:1em;margin-right:0.5em}b,strong{font-family:"AvenirNext-Bold"}i,em{font-family:"AvenirNext-Italic"}code{font-family:"Menlo-Regular"}.text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.sf_code_string,.sf_code_selector,.sf_code_attr-name,.sf_code_char,.sf_code_builtin,.sf_code_inserted{color:#D33905}.sf_code_comment,.sf_code_prolog,.sf_code_doctype,.sf_code_cdata{color:#838383}.sf_code_number,.sf_code_boolean{color:#0E73A2}.sf_code_keyword,.sf_code_atrule,.sf_code_rule,.sf_code_attr-value,.sf_code_function,.sf_code_class-name,.sf_code_class,.sf_code_regex,.sf_code_important,.sf_code_variable,.sf_code_interpolation{color:#0E73A2}.sf_code_property,.sf_code_tag,.sf_code_constant,.sf_code_symbol,.sf_code_deleted{color:#1B00CE}.sf_code_macro,.sf_code_entity,.sf_code_operator,.sf_code_url{color:#920448}.note-wrapper{max-width:46em;margin:0px auto;padding:1.57143em 3.14286em}.note-wrapper.spotlight-preview{overflow-x:hidden}u{text-decoration:none;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#e06e73 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}s{color:#878787}p{margin-bottom:0.1em}hr{margin-bottom:0.7em;margin-top:0.7em}ul li{text-indent:-0.35em}ul li:before{content:"•";color:#e06e73;display:inline-block;margin-right:0.3em}ul ul{margin-left:1.25714em}ol li{text-indent:-1.45em}ol ol{margin-left:1.25714em}blockquote{display:block;margin-left:-1em;padding-left:0.8em;border-left:0.2em solid #e06e73}.todo-list ul{margin-left:1.88571em}.todo-list li{text-indent:-1.75em}.todo-list li:before{content:"";display:static;margin-right:0px}.todo-checkbox{text-indent:-1.7em}.todo-checkbox svg{margin-right:0.3em;position:relative;top:0.2em}.todo-checkbox svg #check{display:none}.todo-checkbox.todo-checked #check{display:inline}.todo-checkbox.todo-checked+.todo-text{text-decoration:line-through;color:#878787}.code-inline{display:inline;background:white;border:solid 1px #dedede;padding:0.2em 0.5em;font-size:0.9em}.code-multiline{display:block;background:white;border:solid 1px #dedede;padding:0.7em 1em;font-size:0.9em;overflow-x:auto}.hashtag{display:inline-block;color:white;background:#b8bfc2;padding:0.0em 0.5em;border-radius:1em;text-indent:0}.hashtag a{color:#fff}.address a{color:#545454;background-image:linear-gradient(to bottom, rgba(0,0,0,0) 50%,#0da35e 50%);background-repeat:repeat-x;background-size:2px 2px;background-position:0 1.05em}.address svg{position:relative;top:0.2em;display:inline-block;margin-right:0.2em}.color-preview{display:inline-block;width:1em;height:1em;border:solid 1px rgba(0,0,0,0.3);border-radius:50%;margin-right:0.1em;position:relative;top:0.2em;white-space:nowrap}.color-code{margin-right:0.2em;font-family:"Menlo-Regular";font-size:0.9em}.color-hash{opacity:0.4}.ordered-list-number{color:#e06e73;text-align:right;display:inline-block;min-width:1em}.arrow svg{position:relative;top:0.08em;display:inline-block;margin-right:0.15em;margin-left:0.15em}.arrow svg #rod{stroke:#545454}.arrow svg #point{fill:#545454}mark{color:inherit;display:inline;padding:0.2em 0.5em;background-color:#fcffc0}img{max-width:100%;height:auto}

        </style>
    </body>
</html>
